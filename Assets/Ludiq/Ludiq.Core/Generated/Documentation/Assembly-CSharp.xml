<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Assembly-CSharp</name>
    </assembly>
    <members>
        <member name="T:MeshBrush.MeshBrush">
            <summary>
            MeshBrush component that provides functionality for painting, deleting and combining meshes in your scenes.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.version">
            <summary>
            The current version of MeshBrush.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.active">
            <summary>
            Activates or deactivates this MeshBrush instance.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.groupName">
            <summary>
            The name for this MeshBrush group (and also its holder object).
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.layerMask">
            <summary>
            Global painting layer mask.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.radius">
            <summary>
            The brush radius.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.color">
            <summary>
            The color of the brush helper handle.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.quantityRange">
            <summary>
            The range within which to choose the amount of meshes to paint.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.useDensity">
            <summary>
            Keep a constant mesh density inside the circle brush area with this option.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.densityRange">
            <summary>
            The range within which to choose the mesh density value in meshes/m².
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.delay">
            <summary>
            The delay between paint strokes when holding down your paint button.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.offsetRange">
            <summary>
            A float variable for the minimum vertical offset of the mesh we are going to paint.<para> </para> 
            You probably won't ever need this if you place the pivot of your meshes nicely, but you never know.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.slopeInfluenceRange">
            <summary>
            The range within which to choose the float value for the influence 
            that the underlying surface normal should have on the painted meshes.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.useSlopeFilter">
            <summary>
            Activate/deactivate the slope filter.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.angleThresholdRange">
            <summary>
            The range within which to choose the float value for the slope filter's angle threshold value
            (adjust this to avoid having meshes painted on steep surfaces such as cliffs and hills).
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.inverseSlopeFilter">
            <summary>
            Invert the slope filter functionality with ease.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.slopeReferenceVector">
            <summary>
            The sampled reference slope vector.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.slopeReferenceVectorSampleLocation">
            <summary>
            The point in space where we sampled our reference slope vector.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.yAxisTangent">
            <summary>
            Determines if the local Y-Axis of painted meshes should be kept tangent to their underlying surface or not.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.strokeAlignment">
            <summary>
            Aligns the painted meshes with the direction of the brush stroke 
            (only works if there is no rotation randomizer set up).
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.autoIgnoreRaycast">
            <summary>
            Should all painted meshes be automatically set to the Ignore Raycast layer?<para> </para>
            This is useful if you want to avoid the meshes to stack up on each other when painting on the same spot over and over.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.scatteringRange">
            <summary>
            The range within which to choose the percentage of scattering applied to the painted meshes 
            (how much they spread out from the center of the circle brush).
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.useOverlapFilter">
            <summary>
            Activate/deactivate the overlap filter.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.minimumAbsoluteDistanceRange">
            <summary>
            Random range within which to choose the minimum absolute distance value for the overlap filter.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.uniformRandomScale">
            <summary>
            Should the random scale value be applied uniformly across all axes?
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.uniformAdditiveScale">
            <summary>
            Should the additive scale value be applied uniformly across all axes (X, Y and Z)?
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.randomScaleRange">
            <summary>
            The range within which to choose the uniform random scale value.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.randomScaleRangeX">
            <summary>
            The range within which to choose the X value for the non-uniform random scale.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.randomScaleRangeY">
            <summary>
            The range within which to choose the Y value for the non-uniform random scale.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.randomScaleRangeZ">
            <summary>
            The range within which to choose the Z value for the non-uniform random scale.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.additiveScaleRange">
            <summary>
            The range within which to choose the additive scale (this value will be added uniformly to all axes after the paint stroke).
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.additiveScaleNonUniform">
            <summary>
            Vector3 variable for the non-uniform additive scale.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.randomScaleCurve">
            <summary>
            The random scale curve.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.randomScaleCurveVariation">
            <summary>
            The random scale curve ± variation.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.randomRotationRange">
            <summary>
            The range within which to choose the randomization percentage around the local-y axis of the painted meshes.<para> </para>
            0% means no randomization at all and 100% means full randomization.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.globalPaintingMode">
            <summary>
            Global painting mode state.<para> </para> 
            The user should have no control over this variable, because it gets 
            set up automatically when a MeshBrush component is added via the MeshBrush 
            menu item under GameObject, or a global painting instance is created (also through that menu)..
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.collapsed">
            <summary>
            Should the MeshBrush component be in a collapsed state? 
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.stats">
            <summary>
            Activates or deactivates the stats label in the inspector.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.lockSceneView">
            <summary>
            Avoids losing focus of the scene view window.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.classicUI">
            <summary>
            Toggle for the classic set of meshes to paint UI.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.previewIconSize">
            <summary>
            Size of the icon boxes that appear in the modern set of meshes to paint UI.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.manualReferenceVectorSampling">
            <summary>
            Manually sample the reference slope vector.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.showReferenceVectorInSceneView">
            <summary>
            Show/hide the reference gui vector in the scene view.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.autoStatic">
            <summary>
            Automatically flag all painted meshes as static.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.autoSelectOnCombine">
            <summary>
            Automatically select the combined mesh after pressing the button in the Optimize foldout?
            </summary>
        </member>
        <member name="P:MeshBrush.MeshBrush.CachedTransform">
            <summary>
            The cached <see cref="T:UnityEngine.Transform"/> component.
            </summary>
        </member>
        <member name="P:MeshBrush.MeshBrush.CachedCollider">
            <summary>
            The cached <see cref="T:UnityEngine.Collider"/> component. 
            </summary>
        </member>
        <member name="P:MeshBrush.MeshBrush.Brush">
            <summary>
            This is the invisible brush <see cref="T:UnityEngine.GameObject"/> that wanders around when painting multiple meshes at once.
            </summary>
        </member>
        <member name="P:MeshBrush.MeshBrush.BrushTransform">
            <summary>
            This is the invisible brush <see cref="T:UnityEngine.Transform"/> that wanders around when painting multiple meshes at once.
            </summary>
        </member>
        <member name="P:MeshBrush.MeshBrush.HolderObj">
            <summary>
            The MeshBrush instance's holder <see cref="T:UnityEngine.Transform"/>;
            this is the root which all painted meshes will be parented to.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.lastPaintLocation">
            <summary>
            The last brush location where meshes have been painted.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.brushStrokeDirection">
            <summary>
            The current direction of the paint stroke.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.meshes">
            <summary>
            This is the set of meshes to paint that can be edited inside the inspector.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.paintedMeshes">
            <summary>
            The painted meshes' <see cref="T:UnityEngine.Transform"/> components.
            </summary>
        </member>
        <member name="F:MeshBrush.MeshBrush.paintedMeshesInsideBrushArea">
            <summary>
            This list contains the <see cref="T:UnityEngine.Transform"/> components that have been gathered via the <see cref="M:MeshBrush.MeshBrush.GatherMeshesInsideBrushArea(UnityEngine.RaycastHit)"/> method.
            </summary>
        </member>
        <member name="M:MeshBrush.MeshBrush.OnValidate">
            <summary>
            Validates the MeshBrush instance settings. 
            Always call this method after changing some settings externally (e.g. at runtime from other scripts)!
            </summary>
        </member>
        <member name="M:MeshBrush.MeshBrush.CleanSetOfMeshesToPaint">
            <summary>
            Cleans up the set of meshes to paint by removing unused null fields.
            </summary>
        </member>
        <member name="M:MeshBrush.MeshBrush.PaintMeshes(UnityEngine.RaycastHit)">
            <summary>
            Paint meshes inside the brush area.
            </summary>
        </member>
        <member name="M:MeshBrush.MeshBrush.RandomizeMeshes(UnityEngine.RaycastHit)">
            <summary>
            Randomize all painted meshes inside the brush area.
            </summary>
        </member>
        <member name="M:MeshBrush.MeshBrush.DeleteMeshes(UnityEngine.RaycastHit)">
            <summary>
            Deletes all painted meshes (except already combined ones) inside the specified brush circle area.
            </summary>
        </member>
        <member name="M:MeshBrush.MeshBrush.CombineMeshes(UnityEngine.RaycastHit)">
            <summary>
            Combines all meshes inside the specified brush circle area.
            </summary>
        </member>
        <member name="M:MeshBrush.MeshBrush.SampleReferenceVector(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Samples the slope filter's reference vector at the specified location.
            </summary>
        </member>
        <member name="M:MeshBrush.MeshBrush.OrientPaintedMesh(UnityEngine.Transform,UnityEngine.RaycastHit)">
            <summary>
            Orients a painted mesh to the specified target location (adjusting position and rotation accordingly).
            </summary>
            <param name="targetTransform">The <see cref="T:UnityEngine.Transform"/> of the painted mesh to orient.</param>
            <param name="targetLocation">The underlying surface to which you want to orient your painted mesh.</param>
        </member>
        <member name="M:MeshBrush.MeshBrush.CheckHolder">
            <summary>
            Checks whether the MeshBrush component has a linked child holder object or not 
            (and creates one if it doesn't).<para> </para>
            The holder GameObject acts as a root for all painted meshes.
            </summary>
        </member>
        <member name="M:MeshBrush.MeshBrush.CheckBrush">
            <summary>
            Checks if there is already a linked brush object and
            creates one if there isn't.<para> </para>
            The brush is needed for multiple mesh painting.
            </summary>
        </member>
        <member name="M:MeshBrush.MeshBrush.SaveTemplate(System.String)">
            <summary>
            Saves a MeshBrush instance out to a template file. 
            </summary>
            <param name="filePath">Where should the template file be stored? Please provide the full path (including the .xml extension).</param>
            <returns>The template's <see cref="T:System.Xml.Linq.XDocument"/> after saving, to allow for further editing and updating.</returns>
        </member>
        <member name="M:MeshBrush.MeshBrush.LoadTemplate(System.String)">
            <summary>
            Loads a MeshBrush template into a MeshBrush instance.
            </summary>
            <param name="filePath">The template file to feed into this MeshBrush instance (full path including .xml extension).</param>
            <returns>True if the loading procedure was successful; false if it failed in some way.</returns>
        </member>
        <member name="M:MeshBrush.MeshBrushParent.FlagMeshesAsStatic">
            <summary>
            Flags all painted meshes under this holder as static.
            </summary>
        </member>
        <member name="M:MeshBrush.MeshBrushParent.UnflagMeshesAsStatic">
            <summary>
            Unflags all painted meshes under this holder as static (making them non-static).
            </summary>
        </member>
        <member name="M:MeshBrush.MeshBrushParent.GetMeshCount">
            <summary>
            Gets the total amount of meshes (<see cref="T:UnityEngine.MeshFilter"/>) under this holder.
            </summary>
        </member>
        <member name="M:MeshBrush.MeshBrushParent.GetTrisCount">
            <summary>
            Gets the total amount of triangles under this holder.
            </summary>
        </member>
        <member name="T:MeshBrush.FavouriteTemplatesUtility">
            <summary>
            Class that provides functionality for saving and loading 
            lists of MeshBrush template files from and to xml files.
            </summary>
        </member>
        <member name="M:MeshBrush.FavouriteTemplatesUtility.SaveFavouriteTemplates(System.Collections.Generic.List{System.String},System.String)">
            <summary>
            Saves a list of MeshBrush template file paths to an xml file.<para> </para>
            Make sure to include the full template file paths (including the .xml extension) in the provided parameter list; invalid or inexistent files won't be written to the final file.
            </summary>
            <param name="favouriteTemplates">The list of full template file paths (including the .xml extension) to write to the xml file.</param>
            <param name="filePath">The full path (including the .xml extension) to the file where the list of favourite MeshBrush templates should be stored.<para> </para>Existing files will be overwritten.</param>
            <returns>The <see cref="T:System.Xml.Linq.XDocument"/> of the favourite templates list that was saved.</returns>
        </member>
        <member name="M:MeshBrush.FavouriteTemplatesUtility.LoadFavouriteTemplates(System.String)">
            <summary>
            Loads a list of favourite MeshBrush template files from a specified xml file (returning a new list each time).
            </summary>
            <returns>A new list containing the loaded MeshBrush template file paths.</returns>
            <param name="filePath">The full path to the xml file that contains the favourite templates to load.</param>
        </member>
        <member name="M:MeshBrush.FavouriteTemplatesUtility.LoadFavouriteTemplates(System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Loads a list of favourite MeshBrush template files from a specified xml file into an existing list of strings.<para> </para>
            Use this overload if you want to avoid the allocation cost of returning a new list each time, but be aware that the provided parameter list will be cleared irreversably before any data is written to it.
            </summary>
            <param name="filePath">The full path to the xml file that contains the favourite templates to load.</param>
            <param name="targetList">The list of strings into which the template file paths should be loaded.</param>
            <returns>True if the loading procedure was successful; false if it failed somehow.</returns>
        </member>
        <member name="T:MeshBrush.MeshTransformationUtility">
            <summary>
            Mesh transformation utility useful for randomizations that require scaling, rotating and/or offsetting existing meshes.
            </summary>
        </member>
        <member name="M:MeshBrush.MeshTransformationUtility.ApplyRandomScale(UnityEngine.Transform,UnityEngine.Vector2)">
            <summary>
            Applies random scale to a <see cref="T:UnityEngine.Transform"/> uniformly and within a defined range.
            </summary>
            <param name="targetTransform">Target transform to randomize.</param>
            <param name="range">Scale range (a random number will be picked between range.x and range.y).</param>
        </member>
        <member name="M:MeshBrush.MeshTransformationUtility.ApplyRandomScale(UnityEngine.Transform,UnityEngine.Vector4)">
            <summary>
            Applies random scale to a <see cref="T:UnityEngine.Transform"/> non-uniformly (width and height based) within defined ranges.
            </summary>
            <param name="targetTransform">Target transform to which the random scale should be applied.</param>
            <param name="scaleRanges">Scale ranges (x and y are the min/max width; z and w are the min/max height).</param>
        </member>
        <member name="M:MeshBrush.MeshTransformationUtility.ApplyRandomScale(UnityEngine.Transform,UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            Applies random scale to a <see cref="T:UnityEngine.Transform"/> non-uniformly and within defined ranges (for each scale axis individually).
            </summary>
            <param name="targetTransform">Target transform to which the scale modification should be applied.</param>
            <param name="rangeX">Minimum/maximum scale along the local x-axis.</param>
            <param name="rangeY">Minimum/maximum scale along the local y-axis.</param>
            <param name="rangeZ">Minimum/maximum scale along the local z-axis.</param>
        </member>
        <member name="M:MeshBrush.MeshTransformationUtility.AddConstantScale(UnityEngine.Transform,UnityEngine.Vector2)">
            <summary>
            Adds a constant scale additively and uniformly to a target <see cref="T:UnityEngine.Transform"/>.
            </summary>
            <param name="targetTransform">Target transform that should be scaled.</param>
            <param name="range">The min/max amount to add to the scale (uniformly across x, y and z).</param>
        </member>
        <member name="M:MeshBrush.MeshTransformationUtility.AddConstantScale(UnityEngine.Transform,System.Single,System.Single,System.Single)">
            <summary>
            Adds a constant scale additively and non-uniformly to a target <see cref="T:UnityEngine.Transform"/>.
            </summary>
            <param name="targetTransform">Target transform that should be scaled.</param>
            <param name="x">The amount of scale to add to the local x axis.</param>
            <param name="y">The amount of scale to add to the local y axis.</param>
            <param name="z">The amount of scale to add to the local z axis.</param>
        </member>
        <member name="M:MeshBrush.MeshTransformationUtility.ApplyRandomRotation(UnityEngine.Transform,System.Single)">
            <summary>
            Apply some random rotation (around the local Y axis) to a <see cref="T:UnityEngine.Transform"/>.
            </summary>
            <param name="targetTransform">Target transform to randomize.</param>
            <param name="randomRotationIntensityPercentage">How intense should the applied random rotation be? [0% - 100%]</param>
        </member>
        <member name="M:MeshBrush.MeshTransformationUtility.ApplyMeshOffset(UnityEngine.Transform,System.Single,UnityEngine.Vector3)">
            <summary>
            Applies the mesh offset (along the local Y axis).
            </summary>
            <param name="targetTransform">Target transform to offset.</param>
            <param name="offset">Offset (in centimeters).</param>
            <param name="direction">Offset direction (in world space).</param>
        </member>
        <member name="T:MeshBrush.TemplateMigrationUtility">
            <summary>
            Utility class for migrating obsolete MeshBrush templates from previous versions to the newest format.
            </summary>
        </member>
        <member name="M:MeshBrush.TemplateMigrationUtility.TryMigrate(System.String)">
            <summary>
            Migrates an old MeshBrush template file from a previous version to the newest format as good as possible (a fully 100% accurate migration is not always possible).<para> </para>
            A completely new template file with the same name, properties and path will be saved, but with a suffix of "__migrated".
            </summary>
            <param name="filePath">The full file path of the template to migrate.</param>
            <returns>True if the migration succeeded; false if it failed somehow.</returns>
        </member>
        <member name="T:MeshBrush.VectorClampingUtility">
            <summary>
            Utility that provides simple clamping functionality for vectors.
            </summary>
        </member>
        <member name="F:InControl.BindingListenOptions.IncludeControllers">
            <summary>
            Include controllers when listening for new bindings.
            </summary>
        </member>
        <member name="F:InControl.BindingListenOptions.IncludeUnknownControllers">
            <summary>
            Include unknown controllers when listening for new bindings.
            </summary>
        </member>
        <member name="F:InControl.BindingListenOptions.IncludeNonStandardControls">
            <summary>
            Include non-standard controls on controllers when listening for new bindings.
            </summary>
        </member>
        <member name="F:InControl.BindingListenOptions.IncludeMouseButtons">
            <summary>
            Include mouse buttons when listening for new bindings.
            </summary>
        </member>
        <member name="F:InControl.BindingListenOptions.IncludeMouseScrollWheel">
            <summary>
            Include mouse scroll wheel when listening for new bindings.
            </summary>
        </member>
        <member name="F:InControl.BindingListenOptions.IncludeKeys">
            <summary>
            Include keyboard keys when listening for new bindings.
            </summary>
        </member>
        <member name="F:InControl.BindingListenOptions.IncludeModifiersAsFirstClassKeys">
            <summary>
            Treat modifiers (Shift, Alt, Control, etc.) as first class keys instead of modifiers.
            </summary>
        </member>
        <member name="F:InControl.BindingListenOptions.MaxAllowedBindings">
            <summary>
            The maximum number of bindings allowed for the action. 
            If a new binding is detected and would cause this number to be exceeded, 
            enough bindings are removed to make room before adding the new binding.
            When zero (default), no limit is applied.
            </summary>
        </member>
        <member name="F:InControl.BindingListenOptions.MaxAllowedBindingsPerType">
            <summary>
            The maximum number of bindings of a given type allowed for the action. 
            If a new binding is detected and would cause this number to be exceeded, 
            enough bindings are removed to make room before adding the new binding.
            When zero (default), no limit is applied.
            When nonzero, this setting overrides MaxAllowedBindings.
            </summary>
        </member>
        <member name="F:InControl.BindingListenOptions.AllowDuplicateBindingsPerSet">
            <summary>
            Allow bindings that are already bound to any other action in the set.
            </summary>
        </member>
        <member name="F:InControl.BindingListenOptions.UnsetDuplicateBindingsOnSet">
            <summary>
            If an existing duplicate binding exists, remove it before adding the new one.
            When <code>true</code>, the value of AllowDuplicateBindingsPerSet is irrelevant.
            </summary>
        </member>
        <member name="F:InControl.BindingListenOptions.RejectRedundantBindings">
            <summary>
            If an existing duplicate binding already exists on the same action, 
            reject the binding instead of accepting it doing nothing.
            </summary>
        </member>
        <member name="F:InControl.BindingListenOptions.ReplaceBinding">
            <summary>
            If not <code>null</code>, and this binding is on the listening action, this binding
            will be replace by the newly found binding.
            </summary>
        </member>
        <member name="F:InControl.BindingListenOptions.OnBindingFound">
            <summary>
            This function is called when a binding is found but before it is added.
            If this function returns <code>false</code>, then the binding is ignored
            and listening for new bindings will continue.
            If set to <code>null</code> (default), it will not be called.
            </summary>
        </member>
        <member name="F:InControl.BindingListenOptions.OnBindingAdded">
            <summary>
            This action is called after a binding is added.
            If set to <code>null</code> (default), it will not be called.
            </summary>
        </member>
        <member name="F:InControl.BindingListenOptions.OnBindingRejected">
            <summary>
            This action is called after a binding is found, but rejected along with 
            the reason (BindingSourceRejectionType) why it was rejected.
            If set to <code>null</code> (default), it will not be called.
            </summary>
        </member>
        <member name="T:InControl.BindingSource">
            <summary>
            The abstract base class for all binding sources.
            A binding source can be bound to an action and provides an input source. It essentially
            represents a control bound to an action, whether it be a controller button, a key or combination
            of keys, or a mouse button, etc. An action may have multiple binding sources bound.
            An InputDevice may serve as context for a binding source, especially in the case of controllers.
            For example, the binding source may be "Left Trigger," but when querying a value for the 
            binding, a specific InputDevice must be provided. Not all bindings require an input
            device. Keyboard or mouse bindings do not.
            </summary>
        </member>
        <member name="M:InControl.BindingSource.GetValue(InControl.InputDevice)">
            <summary>
            Read a float value from the binding source in the context of an optional InputDevice.
            </summary>
            <returns>The value, usually in the range -1..1, but not necessarily, for example, 
            in the case of mouse movement.</returns>
            <param name="inputDevice">An input device which serves as the context for this source, if applicable. Pass in null when not applicable.</param>
        </member>
        <member name="M:InControl.BindingSource.GetState(InControl.InputDevice)">
            <summary>
            Read a bool value from the binding source in the context of an optional InputDevice.
            </summary>
            <returns><c>true</c> if the value of the binding is non-zero; otherwise <c>false</c>.</returns>
            <param name="inputDevice">An input device which serves as the context for this source, if applicable. Pass in null when not applicable.</param>
        </member>
        <member name="M:InControl.BindingSource.Equals(InControl.BindingSource)">
            <summary>
            Determines whether the specified BindingSource is equal to the current BindingSource.
            </summary>
            <param name="other">The BindingSource to compare with the current BindingSource.</param>
            <returns><c>true</c> if the specified BindingSource is equal to the current
            BindingSource; otherwise, <c>false</c>.</returns>
        </member>
        <member name="P:InControl.BindingSource.Name">
            <summary>
            Gets a textual representation of the binding source.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:InControl.BindingSource.DeviceName">
            <summary>
            Gets the name of the device this binding source currently represents.
            </summary>
            <value>The name of the device.</value>
        </member>
        <member name="P:InControl.BindingSource.DeviceClass">
            <summary>
            Gets the class of device this binding source currently represents.
            </summary>
            <value>The class of the device.</value>
        </member>
        <member name="P:InControl.BindingSource.DeviceStyle">
            <summary>
            Gets the style of device this binding source currently represents.
            </summary>
            <value>The style of the device.</value>
        </member>
        <member name="M:InControl.BindingSource.op_Equality(InControl.BindingSource,InControl.BindingSource)">
            <summary>
            Determines whether the specified binding sources are equal.
            </summary>
            <param name="a">The first binding source to compare.</param>
            <param name="b">The second binding source to compare.</param>
            <returns><c>true</c> if the specified binding sources are equal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:InControl.BindingSource.op_Inequality(InControl.BindingSource,InControl.BindingSource)">
            <summary>
            Determines whether the specified binding sources are not equal.
            </summary>
            <param name="a">The first binding source to compare.</param>
            <param name="b">The second binding source to compare.</param>
            <returns><c>true</c> if the specified binding sources are not equal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:InControl.BindingSource.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current BindingSource.
            </summary>
            <param name="obj">The object to compare with the current BindingSource.</param>
            <returns><c>true</c> if the specified object is equal to the current
            BindingSource; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:InControl.BindingSource.GetHashCode">
            <summary>
            Serves as a hash function for a BindingSource object.
            </summary>
            <returns>A hash code for this instance that is suitable for use in 
            hashing algorithms and data structures such as a hash table.</returns>
        </member>
        <member name="T:InControl.KeyCombo">
            <summary>
            Represents a combination of one or more keys, including modifiers, up to a maximum of eight.
            </summary>
        </member>
        <member name="T:InControl.PlayerAction">
            <summary>
            This class represents a single action that may have multiple controls bound to it.
            A bound control is represented by a subclass of BindingSource. For example,
            DeviceBindingSource provides input from a control on any supported InputDevice.
            Similarly, KeyBindingSource provides input from one or more keypresses. An action
            may have any number of bindings.
            Actions have two groups of bindings defined: default bindings and regular bindings.
            Default bindings are the predefined default bindings, and the current bindings for
            the action can be reset to this group in a single operation. Regular bindings are those
            added by users, most likely at runtime in a settings menu or the like. There are no
            other distinctions between these groupings; they are purely for organizational convenience.
            </summary>
        </member>
        <member name="P:InControl.PlayerAction.Name">
            <summary>
            The unique identifier for this action within the context of its owning action set.
            </summary>
        </member>
        <member name="P:InControl.PlayerAction.Owner">
            <summary>
            Gets the owning action set containing this action.
            </summary>
        </member>
        <member name="F:InControl.PlayerAction.ListenOptions">
            <summary>
            Configures how this action listens for new bindings.
            When <c>null</c> (default) the owner's <see cref="P:InControl.PlayerActionSet.ListenOptions"/> will be used.
            <seealso cref="M:InControl.PlayerAction.ListenForBinding"/>
            </summary>
        </member>
        <member name="F:InControl.PlayerAction.LastInputType">
            <summary>
            The binding source type that last provided input to this action.
            </summary>
        </member>
        <member name="E:InControl.PlayerAction.OnLastInputTypeChanged">
            <summary>
            Occurs when the binding source type that last provided input to this action changes.
            </summary>
        </member>
        <member name="F:InControl.PlayerAction.LastInputTypeChangedTick">
            <summary>
            Updated when <see cref="F:InControl.PlayerAction.LastInputType"/> changes.
            </summary>
        </member>
        <member name="F:InControl.PlayerAction.LastDeviceClass">
            <summary>
            The <see cref="T:InControl.InputDeviceClass"/> of the binding source that last provided input to this action.
            </summary>
        </member>
        <member name="F:InControl.PlayerAction.LastDeviceStyle">
            <summary>
            The <see cref="T:InControl.InputDeviceStyle"/> of the binding source that last provided input to this action.
            </summary>
        </member>
        <member name="P:InControl.PlayerAction.UserData">
            <summary>
            This property can be used to store whatever arbitrary game data you want on this action.
            </summary>
        </member>
        <member name="M:InControl.PlayerAction.#ctor(System.String,InControl.PlayerActionSet)">
            <summary>
            Construct an action belonging to a given action set.
            </summary>
            <param name="name">A unique identifier for this action within the context of its owning action set.</param>
            <param name="owner">The action set to contain (own) this action.</param>
        </member>
        <member name="M:InControl.PlayerAction.AddDefaultBinding(InControl.BindingSource)">
            <summary>
            Adds a default binding for the action. This will also add it to the regular bindings.
            </summary>
            <param name="binding">The BindingSource to add.</param>
        </member>
        <member name="M:InControl.PlayerAction.AddDefaultBinding(InControl.Key[])">
            <summary>
            A convenience method for adding a KeyBindingSource to the default bindings.
            </summary>
            <param name="keys">A list of one or more keys making up a KeyCombo for the binding source.</param>
        </member>
        <member name="M:InControl.PlayerAction.AddDefaultBinding(InControl.KeyCombo)">
            <summary>
            A convenience method for adding a KeyBindingSource to the default bindings.
            </summary>
            <param name="keyCombo">A KeyCombo for the binding source.</param>
        </member>
        <member name="M:InControl.PlayerAction.AddDefaultBinding(InControl.Mouse)">
            <summary>
            A convenience method for adding a MouseBindingSource to the default bindings.
            </summary>
            <param name="control">The Mouse control to add.</param>
        </member>
        <member name="M:InControl.PlayerAction.AddDefaultBinding(InControl.InputControlType)">
            <summary>
            A convenience method for adding a DeviceBindingSource to the default bindings.
            </summary>
            <param name="control">The InputControlType to add.</param>
        </member>
        <member name="M:InControl.PlayerAction.AddBinding(InControl.BindingSource)">
            <summary>
            Add a regular binding to the action. A binding cannot be added if it matches an
            existing binding on the action, or if it is already bound to another action.
            </summary>
            <returns><c>true</c>, if binding was added, <c>false</c> otherwise.</returns>
            <param name="binding">The BindingSource to add.</param>
        </member>
        <member name="M:InControl.PlayerAction.InsertBindingAt(System.Int32,InControl.BindingSource)">
            <summary>
            Insert a regular binding to the action at the specified index. A binding cannot be
            inserted if it matches an existing binding on the action, or if it is already bound to
            another action.
            </summary>
            <returns><c>true</c>, if binding was inserted, <c>false</c> otherwise.</returns>
            <param name="binding">The index at which to insert.</param>
            <param name="binding">The BindingSource to insert.</param>
        </member>
        <member name="M:InControl.PlayerAction.ReplaceBinding(InControl.BindingSource,InControl.BindingSource)">
            <summary>
            Add a regular binding to the action replacing an existing binding. A binding cannot be
            added if is already bound to another action. If the binding to replace is not present
            on this action, the binding will not be added.
            </summary>
            <returns><c>true</c>, if binding was added, <c>false</c> otherwise.</returns>
            <param name="findBinding">The BindingSource to replace.</param>
            <param name="withBinding">The BindingSource to replace it with.</param>
        </member>
        <member name="M:InControl.PlayerAction.HasBinding(InControl.BindingSource)">
            <summary>
            Searches all the bindings on this action to see if any that match
            the provided binding object.
            </summary>
            <returns><c>true</c>, if a matching binding is found on this action, 
            <c>false</c> otherwise.</returns>
            <param name="binding">The BindingSource template to search for.</param>
        </member>
        <member name="M:InControl.PlayerAction.FindBinding(InControl.BindingSource)">
            <summary>
            Searches all the bindings on this action to see if any that match
            the provided binding object and, if found, returns it.
            </summary>
            <param name="binding">The BindingSource template to search for.</param>
        </member>
        <member name="M:InControl.PlayerAction.HardRemoveBinding(InControl.BindingSource)">
            <summary>
            Searches all the bindings on this action to see if any that match
            the provided binding object and, if found, removes it.
            Unlike RemoveBinding, this immediately removes it from the Bindings 
            collection and updates the visible set.
            WARNING: This is unsafe to call unless absolutely sure it won't be 
            called while anything is iterating over the Bindings collection.
            </summary>
            <param name="binding">The BindingSource template to search for.</param>
        </member>
        <member name="M:InControl.PlayerAction.RemoveBinding(InControl.BindingSource)">
            <summary>
            Searches all the bindings on this action to see if any that match
            the provided binding object and, if found, removes it.
            NOTE: the action is only marked for removal, and is not immediately 
            removed. This is to allow for safe removal during iteration over the 
            Bindings collection.
            </summary>
            <param name="binding">The BindingSource template to search for.</param>
        </member>
        <member name="M:InControl.PlayerAction.RemoveBindingAt(System.Int32)">
            <summary>
            Removes the binding at the specified index from the action.
            Note: the action is only marked for removal, and is not immediately 
            removed. This is to allow for safe removal during iteration over the 
            Bindings collection.
            </summary>
            <param name="index">The index of the BindingSource in the Bindings collection to remove.</param>
        </member>
        <member name="M:InControl.PlayerAction.ClearBindings">
            <summary>
            Clears the bindings for this action.
            </summary>
        </member>
        <member name="M:InControl.PlayerAction.ResetBindings">
            <summary>
            Resets the bindings to the default bindings.
            </summary>
        </member>
        <member name="M:InControl.PlayerAction.ListenForBinding">
            <summary>
            Begin listening for a new user defined binding.
            Which types of BindingSource are detected depends on the value of ListenOptions and DefaultListenOptions.
            Once one is found, it will be added to the regular bindings for the action and listening will stop.
            </summary>
        </member>
        <member name="M:InControl.PlayerAction.ListenForBindingReplacing(InControl.BindingSource)">
            <summary>
            Begin listening for a new user defined binding, replacing an existing specified binding.
            If the binding to replace is not present on this action, the new binding will fail to be added.
            Which types of BindingSource are detected depends on the value of ListenOptions and DefaultListenOptions.
            Once one is found, it will be added to the regular bindings for the action and listening will stop.
            </summary>
        </member>
        <member name="M:InControl.PlayerAction.StopListeningForBinding">
            <summary>
            Stop listening for new user defined bindings.
            </summary>
        </member>
        <member name="P:InControl.PlayerAction.IsListeningForBinding">
            <summary>
            Gets a value indicating whether this action is listening for new user defined bindings.
            </summary>
        </member>
        <member name="P:InControl.PlayerAction.Bindings">
            <summary>
            Gets the valid (in context of the current device) bindings for this action as a readonly collection.
            What this means is, if your current active controller is an Xbox One controller and you have InputControlType.Options
            bound, it will not be included. This is generally the bindings you should display unless you are doing something custom.
            </summary>
        </member>
        <member name="P:InControl.PlayerAction.UnfilteredBindings">
            <summary>
            Gets ALL bindings for this action (including ones that don't make sense for the current device) as a readonly collection.
            Use of this collection is not recommended unless you really need unfettered access to all the bindings on an action.
            </summary>
        </member>
        <member name="P:InControl.PlayerAction.ActiveDevice">
            <summary>
            Gets the currently active device (controller) if present, otherwise returns a null device which does nothing.
            The currently active device is defined as the last device that provided input to this action.
            When LastInputType is not a device (controller), this will return the null device.
            </summary>
        </member>
        <member name="T:InControl.PlayerActionSet">
            <summary>
            An action set represents a set of actions, usually for a single player. This class must be subclassed to be used.
            An action set can contain both explicit, bindable single value actions (for example, "Jump", "Left" and "Right") and implicit,
            aggregate actions which combine together other actions into one or two axes, for example "Move", which might consist
            of "Left", "Right", "Up" and "Down" filtered into a single two-axis control with its own applied circular deadzone,
            queryable vector value, etc.
            </summary>
        </member>
        <member name="P:InControl.PlayerActionSet.Device">
            <summary>
            Optionally specifies a device which this action set should query from, if applicable.
            When set to <c>null</c> (default) this action set will try to find an active device when required.
            </summary>
        </member>
        <member name="P:InControl.PlayerActionSet.IncludeDevices">
            <summary>
            A list of devices which this action set should include when searching for an active device.
            When empty, all attached devices will be considered.
            </summary>
        </member>
        <member name="P:InControl.PlayerActionSet.ExcludeDevices">
            <summary>
            A list of devices which this action set should exclude when searching for an active device.
            </summary>
        </member>
        <member name="P:InControl.PlayerActionSet.Actions">
            <summary>
            Gets the actions in this action set as a readonly collection.
            </summary>
        </member>
        <member name="P:InControl.PlayerActionSet.UpdateTick">
            <summary>
            The last update tick on which any action in this set changed value.
            </summary>
        </member>
        <member name="F:InControl.PlayerActionSet.LastInputType">
            <summary>
            The binding source type that last provided input to this action set.
            </summary>
        </member>
        <member name="E:InControl.PlayerActionSet.OnLastInputTypeChanged">
            <summary>
            Occurs when the binding source type that last provided input to this action set changes.
            </summary>
        </member>
        <member name="F:InControl.PlayerActionSet.LastInputTypeChangedTick">
            <summary>
            Updated when <see cref="F:InControl.PlayerActionSet.LastInputType"/> changes.
            </summary>
        </member>
        <member name="F:InControl.PlayerActionSet.LastDeviceClass">
            <summary>
            The <see cref="T:InControl.InputDeviceClass"/> of the binding source that last provided input to this action set.
            </summary>
        </member>
        <member name="F:InControl.PlayerActionSet.LastDeviceStyle">
            <summary>
            The <see cref="T:InControl.InputDeviceStyle"/> of the binding source that last provided input to this action set.
            </summary>
        </member>
        <member name="P:InControl.PlayerActionSet.Enabled">
            <summary>
            Whether this action set should produce input. Default: <c>true</c>
            </summary>
        </member>
        <member name="P:InControl.PlayerActionSet.PreventInputWhileListeningForBinding">
            <summary>
            The prevent input to all actions while any action in the set is listening for a binding.
            </summary>
        </member>
        <member name="P:InControl.PlayerActionSet.UserData">
            <summary>
            This property can be used to store whatever arbitrary game data you want on this action set.
            </summary>
        </member>
        <member name="M:InControl.PlayerActionSet.Destroy">
            <summary>
            Properly dispose of this action set. You should make sure to call this when the action set
            will no longer be used or it will result in unnecessary internal processing every frame.
            </summary>
        </member>
        <member name="M:InControl.PlayerActionSet.CreatePlayerAction(System.String)">
            <summary>
            Create an action on this set. This should be performed in the constructor of your PlayerActionSet subclass.
            </summary>
            <param name="name">A unique identifier for this action within the context of this set.</param>
            <exception cref="T:InControl.InControlException">Thrown when trying to create an action with a non-unique name for this set.</exception>
        </member>
        <member name="M:InControl.PlayerActionSet.CreateOneAxisPlayerAction(InControl.PlayerAction,InControl.PlayerAction)">
            <summary>
            Create an aggregate, single-axis action on this set. This should be performed in the constructor of your PlayerActionSet subclass.
            </summary>
            <example>
            <code>
            Throttle = CreateOneAxisPlayerAction( Brake, Accelerate );
            </code>
            </example>
            <param name="negativeAction">The action to query for the negative component of the axis.</param>
            <param name="positiveAction">The action to query for the positive component of the axis.</param>
        </member>
        <member name="M:InControl.PlayerActionSet.CreateTwoAxisPlayerAction(InControl.PlayerAction,InControl.PlayerAction,InControl.PlayerAction,InControl.PlayerAction)">
            <summary>
            Create an aggregate, double-axis action on this set. This should be performed in the constructor of your PlayerActionSet subclass.
            </summary>
            <example>
            Note that, due to Unity's positive up-vector, the parameter order of <c>negativeYAction</c> and <c>positiveYAction</c> might seem counter-intuitive.
            <code>
            Move = CreateTwoAxisPlayerAction( Left, Right, Down, Up );
            </code>
            </example>
            <param name="negativeXAction">The action to query for the negative component of the X axis.</param>
            <param name="positiveXAction">The action to query for the positive component of the X axis.</param>
            <param name="negativeYAction">The action to query for the negative component of the Y axis.</param>
            <param name="positiveYAction">The action to query for the positive component of the Y axis.</param>
        </member>
        <member name="P:InControl.PlayerActionSet.Item(System.String)">
            <summary>
            Gets the action with the specified action name. If the action does not exist, <c>KeyNotFoundException</c> is thrown.
            </summary>
            <param name="actionName">The name of the action to get.</param>
        </member>
        <member name="M:InControl.PlayerActionSet.GetPlayerActionByName(System.String)">
            <summary>
            Gets the action with the specified action name. If the action does not exist, it returns <c>null</c>.
            </summary>
            <param name="actionName">The name of the action to get.</param>
        </member>
        <member name="M:InControl.PlayerActionSet.Reset">
            <summary>
            Reset the bindings on all actions in this set.
            </summary>
        </member>
        <member name="M:InControl.PlayerActionSet.HasBinding(InControl.BindingSource)">
            <summary>
            Searches all the bindings on all the actions on this set to see if any 
            match the provided binding object.
            </summary>
            <returns><c>true</c>, if a matching binding is found on any action on
            this set, <c>false</c> otherwise.</returns>
            <param name="binding">The BindingSource template to search for.</param>
        </member>
        <member name="M:InControl.PlayerActionSet.RemoveBinding(InControl.BindingSource)">
            <summary>
            Searches all the bindings on all the actions on this set to see if any 
            match the provided binding object and, if found, removes it.
            </summary>
            <param name="binding">The BindingSource template to search for.</param>
        </member>
        <member name="P:InControl.PlayerActionSet.IsListeningForBinding">
            <summary>
            Query whether any action in this set is currently listening for a new binding.
            </summary>
        </member>
        <member name="P:InControl.PlayerActionSet.ListenOptions">
            <summary>
            Configures how in an action in this set listens for new bindings when the action does not
            explicitly define its own listen options.
            </summary>
        </member>
        <member name="P:InControl.PlayerActionSet.ActiveDevice">
            <summary>
            Gets the currently active device (controller) if present, otherwise returns a null device which does nothing.
            The currently active device is defined as the last device that provided input to an action on this set.
            When LastInputType is not a device (controller), this will return the null device.
            </summary>
        </member>
        <member name="M:InControl.PlayerActionSet.Save">
            <summary>
            Returns the state of this action set and all bindings encoded into a string
            that you can save somewhere.
            Pass this string to Load() to restore the state of this action set.
            </summary>
        </member>
        <member name="M:InControl.PlayerActionSet.Load(System.String)">
            <summary>
            Load a state returned by calling Save() at a prior time.
            </summary>
            <param name="data">The data string.</param>
        </member>
        <member name="F:InControl.PlayerOneAxisAction.LastInputType">
            <summary>
            The binding source type that last provided input to this action set.
            </summary>
        </member>
        <member name="E:InControl.PlayerOneAxisAction.OnLastInputTypeChanged">
            <summary>
            Occurs when the binding source type that last provided input to this action set changes.
            </summary>
        </member>
        <member name="P:InControl.PlayerOneAxisAction.UserData">
            <summary>
            This property can be used to store whatever arbitrary game data you want on this action.
            </summary>
        </member>
        <member name="P:InControl.PlayerTwoAxisAction.InvertXAxis">
            <summary>
            Gets or sets a value indicating whether the X axis should be inverted for
            this action. When false (default), the X axis will be positive up,
            the same as Unity.
            </summary>
        </member>
        <member name="P:InControl.PlayerTwoAxisAction.InvertYAxis">
            <summary>
            Gets or sets a value indicating whether the Y axis should be inverted for
            this action. When false (default), the Y axis will be positive up,
            the same as Unity.
            </summary>
        </member>
        <member name="F:InControl.PlayerTwoAxisAction.LastInputType">
            <summary>
            The binding source type that last provided input to this action set.
            </summary>
        </member>
        <member name="E:InControl.PlayerTwoAxisAction.OnLastInputTypeChanged">
            <summary>
            Occurs when the binding source type that last provided input to this action set changes.
            </summary>
        </member>
        <member name="P:InControl.PlayerTwoAxisAction.UserData">
            <summary>
            This property can be used to store whatever arbitrary game data you want on this action.
            </summary>
        </member>
        <member name="M:InControl.UnknownDeviceControl.op_Equality(InControl.UnknownDeviceControl,InControl.UnknownDeviceControl)">
            <summary>
            Determines whether the specified objects are equal.
            </summary>
            <param name="a">The first object to compare.</param>
            <param name="b">The second object to compare.</param>
            <returns><c>true</c> if the specified objects are equal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:InControl.UnknownDeviceControl.op_Inequality(InControl.UnknownDeviceControl,InControl.UnknownDeviceControl)">
            <summary>
            Determines whether the specified objects are not equal.
            </summary>
            <param name="a">The first object to compare.</param>
            <param name="b">The second object to compare.</param>
            <returns><c>true</c> if the specified objects are not equal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:InControl.UnknownDeviceControl.Equals(InControl.UnknownDeviceControl)">
            <summary>
            Determines whether the specified object is equal to the current object.
            </summary>
            <param name="other">The object to compare with the current object.</param>
            <returns><c>true</c> if the specified object is equal to the current
            object; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:InControl.UnknownDeviceControl.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current object.
            </summary>
            <param name="other">The object to compare with the current object.</param>
            <returns><c>true</c> if the specified object is equal to the current
            object; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:InControl.UnknownDeviceControl.GetHashCode">
            <summary>
            Serves as a hash function for this object.
            </summary>
            <returns>A hash code for this instance that is suitable for use in 
            hashing algorithms and data structures such as a hash table.</returns>
        </member>
        <member name="M:InControl.UnknownDeviceControl.op_Implicit(InControl.UnknownDeviceControl)~System.Boolean">
            <summary>
            Returns true if the Control property is not InputControlType.None
            </summary>
        </member>
        <member name="F:InControl.InputControl.Passive">
            <summary>
            When a control is passive, it will not cause a device to be considered active.
            This is useful for certain controls that spam data, like gyro or
            accelerometer input.
            Defaults to <code>false</code>.
            </summary>
        </member>
        <member name="T:InControl.InputControlType">
            <summary>
            An enumeration of input controls.
            This includes both the standardized set of controls and a variety 
            of non-standard and generic unnamed controls.
            </summary>
        </member>
        <member name="T:InControl.InputRange">
            <summary>
            This type represents a range inclusive of two values, and can remap a value from one range to another.
            </summary>
        </member>
        <member name="F:InControl.InputRange.Value0">
            <summary>
            The first value in the range.
            </summary>
        </member>
        <member name="F:InControl.InputRange.Value1">
            <summary>
            The second value in the range.
            </summary>
        </member>
        <member name="F:InControl.InputRange.Type">
            <summary>
            An enum type of the range.
            </summary>
        </member>
        <member name="M:InControl.InputRange.#ctor(System.Single,System.Single,InControl.InputRangeType)">
            <summary>
            Initializes a new range from two given values.
            </summary>
            <param name="value0">The first value in the range.</param>
            <param name="value1">The second value in the range.</param>
        </member>
        <member name="M:InControl.InputRange.#ctor(InControl.InputRangeType)">
            <summary>
            Initializes a new range from a predefined type.
            </summary>
        </member>
        <member name="M:InControl.InputRange.Includes(System.Single)">
            <summary>
            Check whether a value falls within of this range.
            </summary>
            <returns><c>true</c>, if the value falls within this range, <c>false</c> otherwise.</returns>
            <param name="value">The value to check.</param>
        </member>
        <member name="M:InControl.InputRange.Excludes(System.Single)">
            <summary>
            Check whether a value falls outside of this range.
            </summary>
            <returns><c>true</c>, if the value falls outside this range, <c>false</c> otherwise.</returns>
            <param name="value">The value to check.</param>
        </member>
        <member name="M:InControl.InputRange.Remap(System.Single,InControl.InputRange,InControl.InputRange)">
            <summary>
            Remap the specified value, from one range to another.
            </summary>
            <param name="value">The value to remap.</param>
            <param name="sourceRange">The source range to map from.</param>
            <param name="targetRange">The target range to map to.</param>
        </member>
        <member name="F:InControl.InputDevice.Passive">
            <summary>
            When a device is passive, it will never be considered an active device.
            This may be useful if you want a device to be accessible, but not
            show up in places where active devices are used. 
            Defaults to <code>false</code>.
            </summary>
        </member>
        <member name="M:InControl.InputDevice.GetControl(InControl.InputControlType)">
            <summary>
            Gets the control with the specified control type. If the control does not exist, <c>InputControl.Null</c> is returned.
            </summary>
            <param name="controlType">The control type of the control to get.</param>
        </member>
        <member name="P:InControl.InputDevice.Item(InControl.InputControlType)">
            <summary>
            Gets the control with the specified control type. If the control does not exist, <c>InputControl.Null</c> is returned.
            </summary>
            <param name="controlType">The control type of the control to get.</param>
        </member>
        <member name="F:InControl.InputManager.Devices">
            <summary>
            A readonly collection of devices.
            Not every device in this list is guaranteed to be attached or even a controller.
            This collection should be treated as a pool from which devices may be selected.
            The collection is in no particular order and the order may change at any time.
            Do not treat this collection as a list of players.
            </summary>
        </member>
        <member name="P:InControl.InputManager.CommandWasPressed">
            <summary>
            Query whether a command button was pressed on any device during the last frame of input.
            </summary>
        </member>
        <member name="P:InControl.InputManager.InvertYAxis">
            <summary>
            Gets or sets a value indicating whether the Y axis should be inverted for
            two-axis (directional) controls. When false (default), the Y axis will be positive up,
            the same as Unity.
            </summary>
        </member>
        <member name="P:InControl.InputManager.IsSetup">
            <summary>
            Gets a value indicating whether the InputManager is currently setup and running.
            </summary>
        </member>
        <member name="M:InControl.InputManager.Setup">
            <summary>
            DEPRECATED: Use the InControlManager component instead.
            </summary>
            @deprecated
            Calling this method directly is no longer supported. Use the InControlManager component to
            manage the lifecycle of the input manager instead.
        </member>
        <member name="M:InControl.InputManager.Reset">
            <summary>
            DEPRECATED: Use the InControlManager component instead.
            </summary>
            @deprecated
            Calling this method directly is no longer supported. Use the InControlManager component to
            manage the lifecycle of the input manager instead.
        </member>
        <member name="M:InControl.InputManager.Update">
            <summary>
            DEPRECATED: Use the InControlManager component instead.
            </summary>
            @deprecated
            Calling this method directly is no longer supported. Use the InControlManager component to
            manage the lifecycle of the input manager instead.
        </member>
        <member name="M:InControl.InputManager.Reload">
            <summary>
            Force the input manager to reset and setup.
            </summary>
        </member>
        <member name="M:InControl.InputManager.ClearInputState">
            <summary>
            Clears the state of input on all controls.
            The net result here should be that the state on all controls will return
            zero/false for the remainder of the current tick, and during the next update
            tick WasPressed, WasReleased, WasRepeated and HasChanged will return false.
            </summary>
        </member>
        <member name="M:InControl.InputManager.AddDeviceManager(InControl.InputDeviceManager)">
            <summary>
            Adds a device manager.
            Only one instance of a given type can be added. An error will be raised if
            you try to add more than one.
            </summary>
            <param name="deviceManager">The device manager to add.</param>
        </member>
        <member name="M:InControl.InputManager.AddDeviceManager``1">
            <summary>
            Adds a device manager by type.
            </summary>
            <typeparam name="T">A subclass of InputDeviceManager.</typeparam>
        </member>
        <member name="M:InControl.InputManager.GetDeviceManager``1">
            <summary>
            Get a device manager from the input manager by type if it one is present.
            </summary>
            <typeparam name="T">A subclass of InputDeviceManager.</typeparam>
        </member>
        <member name="M:InControl.InputManager.HasDeviceManager``1">
            <summary>
            Query whether a device manager is present by type.
            </summary>
            <typeparam name="T">A subclass of InputDeviceManager.</typeparam>
        </member>
        <member name="M:InControl.InputManager.AttachDevice(InControl.InputDevice)">
            <summary>
            Attach a device to the input manager.
            </summary>
            <param name="inputDevice">The input device to attach.</param>
        </member>
        <member name="M:InControl.InputManager.DetachDevice(InControl.InputDevice)">
            <summary>
            Detach a device from the input manager.
            </summary>
            <param name="inputDevice">The input device to attach.</param>
        </member>
        <member name="M:InControl.InputManager.HideDevicesWithProfile(System.Type)">
            <summary>
            Hides the devices with a given profile.
            This must be called before the input manager is initialized.
            </summary>
            <param name="type">Type.</param>
        </member>
        <member name="P:InControl.InputManager.AnyKeyIsPressed">
            <summary>
            Detects whether any (keyboard) key is currently pressed.
            For more flexibility, see <see cref="!:KeyCombo.Detect()"/>
            </summary>
        </member>
        <member name="P:InControl.InputManager.ActiveDevice">
            <summary>
            Gets the currently active device if present, otherwise returns a null device which does nothing.
            The currently active device is defined as the last device that provided input events. This is
            a good way to query for a device in single player applications.
            </summary>
        </member>
        <member name="P:InControl.InputManager.Enabled">
            <summary>
            Toggle whether input is processed or not. While disabled, all controls will return zero state.
            </summary>
        </member>
        <member name="P:InControl.InputManager.SuspendInBackground">
            <summary>
            Suspend input updates when the application loses focus.
            When enabled and the app loses focus, input will be cleared and no.
            input updates will be processed. Input updates will resume when the app 
            regains focus.
            </summary>
        </member>
        <member name="P:InControl.InputManager.EnableNativeInput">
            <summary>
            Enable Native Input support.
            When enabled on initialization, the input manager will first check
            whether Native Input is supported on this platform and if so, it will add
            a NativeInputDeviceManager.
            </summary>
        </member>
        <member name="P:InControl.InputManager.EnableXInput">
            <summary>
            Enable XInput support (Windows only).
            When enabled on initialization, the input manager will first check
            whether XInput is supported on this platform and if so, it will add
            an XInputDeviceManager.
            </summary>
        </member>
        <member name="P:InControl.InputManager.XInputUpdateRate">
            <summary>
            Set the XInput background thread polling rate.
            When set to zero (default) it will equal the projects fixed updated rate.
            </summary>
        </member>
        <member name="P:InControl.InputManager.XInputBufferSize">
            <summary>
            Set the XInput buffer size. (Experimental)
            Usually you want this to be zero (default). Setting it higher will introduce
            latency, but may smooth out input if querying input on FixedUpdate, which
            tends to cluster calls at the end of a frame.
            </summary>
        </member>
        <member name="P:InControl.InputManager.NativeInputEnableXInput">
            <summary>
            Set Native Input on Windows to use XInput.
            When set to true (default), XInput will be utilized which better supports
            compatible controllers (such as Xbox 360 and Xbox One gamepads) including
            vibration control and proper separated triggers, but limits the number of 
            these controllers to four. Additional XInput-compatible beyond four 
            controllers will be ignored.
            DirectInput will be used for all non-XInput-compatible controllers.
            </summary>
        </member>
        <member name="P:InControl.InputManager.NativeInputPreventSleep">
            <summary>
            Set Native Input to prevent system sleep and screensaver.
            Controller input generally does not prevent the system idle timer and
            the screensaver may come on during extended gameplay. When set to
            true, this will be prevented.
            </summary>
        </member>
        <member name="P:InControl.InputManager.NativeInputUpdateRate">
            <summary>
            Set the Native Input background thread polling rate.
            When set to zero (default) it will equal the project's fixed update rate.
            </summary>
        </member>
        <member name="P:InControl.InputManager.EnableICade">
            <summary>
            Enable iCade support (iOS only).
            When enabled on initialization, the input manager will first check
            whether XInput is supported on this platform and if so, it will add
            an XInputDeviceManager.
            </summary>
        </member>
        <member name="T:InControl.CustomInputDeviceProfile">
            <summary>
            "Custom profiles" are deprecated in favor of the new user bindings API.
            See the PlayerAction and PlayerActionSet classes which accomplish the same goal
            much more elegantly and supports runtime remapping.
            http://www.gallantgames.com/pages/incontrol-binding-actions-to-controls 
            </summary>
        </member>
        <member name="T:InControl.VersionInfo">
            <summary>
            Encapsulates a comparable version number.
            This version number generally conforms to the semantic version system, 
            at least as far as InControl versioning is concerned.
            </summary>
        </member>
        <member name="F:InControl.VersionInfo.Major">
            <summary>
            The major version component.
            This number changes when significant incompatible API changes are made.
            </summary>
        </member>
        <member name="F:InControl.VersionInfo.Minor">
            <summary>
            The minor version component.
            This number changes when significant functionality is added in a backwards-compatible manner.
            </summary>
        </member>
        <member name="F:InControl.VersionInfo.Patch">
            <summary>
            The patch version component.
            This number is changed when bug fixes are added in a backwards-compatible manner.
            </summary>
        </member>
        <member name="F:InControl.VersionInfo.Build">
            <summary>
            The build version component.
            This number is incremented during development.
            </summary>
        </member>
        <member name="M:InControl.VersionInfo.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:InControl.VersionInfo"/> with 
            given version components.
            </summary>
            <param name="major">The major version component.</param>
            <param name="minor">The minor version component.</param>
            <param name="patch">The patch version component.</param>
            <param name="build">The build version component.</param>
        </member>
        <member name="M:InControl.VersionInfo.InControlVersion">
            <summary>
            Initialize an instance of <see cref="T:InControl.VersionInfo"/> with
            the current version of InControl.
            </summary>
            <returns>The current version of InControl.</returns>
        </member>
        <member name="M:InControl.VersionInfo.UnityVersion">
            <summary>
            Initialize an instance of <see cref="T:InControl.VersionInfo"/> with
            the current version of Unity.
            </summary>
            <returns>The current version of Unity.</returns>
        </member>
        <member name="P:InControl.VersionInfo.Min">
            <summary>
            Generates the minimum possible version number.
            </summary>
        </member>
        <member name="P:InControl.VersionInfo.Max">
            <summary>
            Generates the maximum possible version number.
            </summary>
        </member>
        <member name="M:InControl.VersionInfo.CompareTo(InControl.VersionInfo)">
            <summary>
            Returns the sort order of the current instance compared to the specified object.
            </summary>
        </member>
        <member name="M:InControl.VersionInfo.op_Equality(InControl.VersionInfo,InControl.VersionInfo)">
            <summary>
            Compares two instances of <see cref="T:InControl.VersionInfo"/> for equality.
            </summary>
        </member>
        <member name="M:InControl.VersionInfo.op_Inequality(InControl.VersionInfo,InControl.VersionInfo)">
            <summary>
            Compares two instances of <see cref="T:InControl.VersionInfo"/> for inequality.
            </summary>
        </member>
        <member name="M:InControl.VersionInfo.op_LessThanOrEqual(InControl.VersionInfo,InControl.VersionInfo)">
            <summary>
            Compares two instances of <see cref="T:InControl.VersionInfo"/> to see if 
            the first is equal to or smaller than the second.
            </summary>
        </member>
        <member name="M:InControl.VersionInfo.op_GreaterThanOrEqual(InControl.VersionInfo,InControl.VersionInfo)">
            <summary>
            Compares two instances of <see cref="T:InControl.VersionInfo"/> to see if 
            the first is equal to or larger than the second.
            </summary>
        </member>
        <member name="M:InControl.VersionInfo.op_LessThan(InControl.VersionInfo,InControl.VersionInfo)">
            <summary>
            Compares two instances of <see cref="T:InControl.VersionInfo"/> to see if 
            the first is smaller than the second.
            </summary>
        </member>
        <member name="M:InControl.VersionInfo.op_GreaterThan(InControl.VersionInfo,InControl.VersionInfo)">
            <summary>
            Compares two instances of <see cref="T:InControl.VersionInfo"/> to see if 
            the first is larger than the second.
            </summary>
        </member>
        <member name="M:InControl.VersionInfo.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:InControl.VersionInfo"/>.
            </summary>
            <param name="other">The <see cref="T:System.Object"/> to compare with the current <see cref="T:InControl.VersionInfo"/>.</param>
            <returns><c>true</c> if the specified <see cref="T:System.Object"/> is equal to the current
            <see cref="T:InControl.VersionInfo"/>; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:InControl.VersionInfo.GetHashCode">
            <summary>
            Serves as a hash function for a <see cref="T:InControl.VersionInfo"/> object.
            </summary>
            <returns>A hash code for this instance that is suitable for use in hashing algorithms 
            and data structures such as a hash table.</returns>
        </member>
        <member name="M:InControl.VersionInfo.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:InControl.VersionInfo"/>.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents the current <see cref="T:InControl.VersionInfo"/>.</returns>
        </member>
        <member name="M:InControl.VersionInfo.ToShortString">
            <summary>
            Returns a shorter <see cref="T:System.String"/> that represents the current <see cref="T:InControl.VersionInfo"/>.
            </summary>
            <returns>A shorter <see cref="T:System.String"/> that represents the current <see cref="T:InControl.VersionInfo"/>.</returns>
        </member>
        <member name="M:UniRx.CompositeDisposable.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Reactive.Disposables.CompositeDisposable"/> class with no disposables contained by it initially.
            </summary>
        </member>
        <member name="M:UniRx.CompositeDisposable.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Reactive.Disposables.CompositeDisposable"/> class with the specified number of disposables.
            </summary>
            <param name="capacity">The number of disposables that the new CompositeDisposable can initially store.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> is less than zero.</exception>
        </member>
        <member name="M:UniRx.CompositeDisposable.#ctor(System.IDisposable[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Reactive.Disposables.CompositeDisposable"/> class from a group of disposables.
            </summary>
            <param name="disposables">Disposables that will be disposed together.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="disposables"/> is null.</exception>
        </member>
        <member name="M:UniRx.CompositeDisposable.#ctor(System.Collections.Generic.IEnumerable{System.IDisposable})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Reactive.Disposables.CompositeDisposable"/> class from a group of disposables.
            </summary>
            <param name="disposables">Disposables that will be disposed together.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="disposables"/> is null.</exception>
        </member>
        <member name="P:UniRx.CompositeDisposable.Count">
            <summary>
            Gets the number of disposables contained in the CompositeDisposable.
            </summary>
        </member>
        <member name="M:UniRx.CompositeDisposable.Add(System.IDisposable)">
            <summary>
            Adds a disposable to the CompositeDisposable or disposes the disposable if the CompositeDisposable is disposed.
            </summary>
            <param name="item">Disposable to add.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> is null.</exception>
        </member>
        <member name="M:UniRx.CompositeDisposable.Remove(System.IDisposable)">
            <summary>
            Removes and disposes the first occurrence of a disposable from the CompositeDisposable.
            </summary>
            <param name="item">Disposable to remove.</param>
            <returns>true if found; false otherwise.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> is null.</exception>
        </member>
        <member name="M:UniRx.CompositeDisposable.Dispose">
            <summary>
            Disposes all disposables in the group and removes them from the group.
            </summary>
        </member>
        <member name="M:UniRx.CompositeDisposable.Clear">
            <summary>
            Removes and disposes all disposables from the CompositeDisposable, but does not dispose the CompositeDisposable.
            </summary>
        </member>
        <member name="M:UniRx.CompositeDisposable.Contains(System.IDisposable)">
            <summary>
            Determines whether the CompositeDisposable contains a specific disposable.
            </summary>
            <param name="item">Disposable to search for.</param>
            <returns>true if the disposable was found; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="item"/> is null.</exception>
        </member>
        <member name="M:UniRx.CompositeDisposable.CopyTo(System.IDisposable[],System.Int32)">
            <summary>
            Copies the disposables contained in the CompositeDisposable to an array, starting at a particular array index.
            </summary>
            <param name="array">Array to copy the contained disposables to.</param>
            <param name="arrayIndex">Target index at which to copy the first disposable of the group.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than zero. -or - <paramref name="arrayIndex"/> is larger than or equal to the array length.</exception>
        </member>
        <member name="P:UniRx.CompositeDisposable.IsReadOnly">
            <summary>
            Always returns false.
            </summary>
        </member>
        <member name="M:UniRx.CompositeDisposable.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the CompositeDisposable.
            </summary>
            <returns>An enumerator to iterate over the disposables.</returns>
        </member>
        <member name="M:UniRx.CompositeDisposable.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the CompositeDisposable.
            </summary>
            <returns>An enumerator to iterate over the disposables.</returns>
        </member>
        <member name="P:UniRx.CompositeDisposable.IsDisposed">
            <summary>
            Gets a value that indicates whether the object is disposed.
            </summary>
        </member>
        <member name="M:UniRx.DisposableExtensions.AddTo``1(``0,System.Collections.Generic.ICollection{System.IDisposable})">
            <summary>Add disposable(self) to CompositeDisposable(or other ICollection). Return value is self disposable.</summary>
        </member>
        <member name="M:UniRx.DisposableExtensions.AddTo``1(``0,UnityEngine.GameObject)">
            <summary>Dispose self on target gameObject has been destroyed. Return value is self disposable.</summary>
        </member>
        <member name="M:UniRx.DisposableExtensions.AddTo``1(``0,UnityEngine.Component)">
            <summary>Dispose self on target gameObject has been destroyed. Return value is self disposable.</summary>
        </member>
        <member name="M:UniRx.DisposableExtensions.AddTo``1(``0,System.Collections.Generic.ICollection{System.IDisposable},UnityEngine.GameObject)">
            <summary>
            <para>Add disposable(self) to CompositeDisposable(or other ICollection) and Dispose self on target gameObject has been destroyed.</para>
            <para>Return value is self disposable.</para>
            </summary>
        </member>
        <member name="M:UniRx.DisposableExtensions.AddTo``1(``0,System.Collections.Generic.ICollection{System.IDisposable},UnityEngine.Component)">
            <summary>
            <para>Add disposable(self) to CompositeDisposable(or other ICollection) and Dispose self on target gameObject has been destroyed.</para>
            <para>Return value is self disposable.</para>
            </summary>
        </member>
        <member name="T:UniRx.RefCountDisposable">
            <summary>
            Represents a disposable resource that only disposes its underlying disposable resource when all <see cref="M:UniRx.RefCountDisposable.GetDisposable">dependent disposable objects</see> have been disposed.
            </summary>
        </member>
        <member name="M:UniRx.RefCountDisposable.#ctor(System.IDisposable)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Reactive.Disposables.RefCountDisposable"/> class with the specified disposable.
            </summary>
            <param name="disposable">Underlying disposable.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="disposable"/> is null.</exception>
        </member>
        <member name="P:UniRx.RefCountDisposable.IsDisposed">
            <summary>
            Gets a value that indicates whether the object is disposed.
            </summary>
        </member>
        <member name="M:UniRx.RefCountDisposable.GetDisposable">
            <summary>
            Returns a dependent disposable that when disposed decreases the refcount on the underlying disposable.
            </summary>
            <returns>A dependent disposable contributing to the reference count that manages the underlying disposable's lifetime.</returns>
        </member>
        <member name="M:UniRx.RefCountDisposable.Dispose">
            <summary>
            Disposes the underlying disposable only when all dependent disposables have been disposed.
            </summary>
        </member>
        <member name="M:UniRx.Observable.Share``1(UniRx.IObservable{``0})">
            <summary>
            same as Publish().RefCount()
            </summary>
        </member>
        <member name="M:UniRx.Observable.WhenAll``1(UniRx.IObservable{``0}[])">
            <summary>
            <para>Specialized for single async operations like Task.WhenAll, Zip.Take(1).</para>
            <para>If sequence is empty, return T[0] array.</para>
            </summary>
        </member>
        <member name="M:UniRx.Observable.WhenAll(UniRx.IObservable{UniRx.Unit}[])">
            <summary>
            <para>Specialized for single async operations like Task.WhenAll, Zip.Take(1).</para>
            </summary>
        </member>
        <member name="M:UniRx.Observable.WhenAll``1(System.Collections.Generic.IEnumerable{UniRx.IObservable{``0}})">
            <summary>
            <para>Specialized for single async operations like Task.WhenAll, Zip.Take(1).</para>
            <para>If sequence is empty, return T[0] array.</para>
            </summary>
        </member>
        <member name="M:UniRx.Observable.WhenAll(System.Collections.Generic.IEnumerable{UniRx.IObservable{UniRx.Unit}})">
            <summary>
            <para>Specialized for single async operations like Task.WhenAll, Zip.Take(1).</para>
            </summary>
        </member>
        <member name="M:UniRx.Observable.Cast``2(UniRx.IObservable{``0},``1)">
            <summary>
            witness is for type inference.
            </summary>
        </member>
        <member name="M:UniRx.Observable.OfType``2(UniRx.IObservable{``0},``1)">
            <summary>
            witness is for type inference.
            </summary>
        </member>
        <member name="M:UniRx.Observable.AsUnitObservable``1(UniRx.IObservable{``0})">
            <summary>
            Converting .Select(_ => Unit.Default) sequence.
            </summary>
        </member>
        <member name="M:UniRx.Observable.AsSingleUnitObservable``1(UniRx.IObservable{``0})">
            <summary>
            Same as LastOrDefault().AsUnitObservable().
            </summary>
        </member>
        <member name="M:UniRx.Observable.Create``1(System.Func{UniRx.IObserver{``0},System.IDisposable})">
            <summary>
            Create anonymous observable. Observer has exception durability. This is recommended for make operator and event like generator. 
            </summary>
        </member>
        <member name="M:UniRx.Observable.Create``1(System.Func{UniRx.IObserver{``0},System.IDisposable},System.Boolean)">
            <summary>
            Create anonymous observable. Observer has exception durability. This is recommended for make operator and event like generator(HotObservable). 
            </summary>
        </member>
        <member name="M:UniRx.Observable.CreateWithState``2(``1,System.Func{``1,UniRx.IObserver{``0},System.IDisposable})">
            <summary>
            Create anonymous observable. Observer has exception durability. This is recommended for make operator and event like generator. 
            </summary>
        </member>
        <member name="M:UniRx.Observable.CreateWithState``2(``1,System.Func{``1,UniRx.IObserver{``0},System.IDisposable},System.Boolean)">
            <summary>
            Create anonymous observable. Observer has exception durability. This is recommended for make operator and event like generator(HotObservable). 
            </summary>
        </member>
        <member name="M:UniRx.Observable.CreateSafe``1(System.Func{UniRx.IObserver{``0},System.IDisposable})">
            <summary>
            Create anonymous observable. Safe means auto detach when error raised in onNext pipeline. This is recommended for make generator (ColdObservable).
            </summary>
        </member>
        <member name="M:UniRx.Observable.CreateSafe``1(System.Func{UniRx.IObserver{``0},System.IDisposable},System.Boolean)">
            <summary>
            Create anonymous observable. Safe means auto detach when error raised in onNext pipeline. This is recommended for make generator (ColdObservable).
            </summary>
        </member>
        <member name="M:UniRx.Observable.Empty``1">
            <summary>
            Empty Observable. Returns only OnCompleted.
            </summary>
        </member>
        <member name="M:UniRx.Observable.Empty``1(UniRx.IScheduler)">
            <summary>
            Empty Observable. Returns only OnCompleted on specified scheduler.
            </summary>
        </member>
        <member name="M:UniRx.Observable.Empty``1(``0)">
            <summary>
            Empty Observable. Returns only OnCompleted. witness is for type inference.
            </summary>
        </member>
        <member name="M:UniRx.Observable.Empty``1(UniRx.IScheduler,``0)">
            <summary>
            Empty Observable. Returns only OnCompleted on specified scheduler. witness is for type inference.
            </summary>
        </member>
        <member name="M:UniRx.Observable.Never``1">
            <summary>
            Non-Terminating Observable. It's no returns, never finish.
            </summary>
        </member>
        <member name="M:UniRx.Observable.Never``1(``0)">
            <summary>
            Non-Terminating Observable. It's no returns, never finish. witness is for type inference.
            </summary>
        </member>
        <member name="M:UniRx.Observable.Return``1(``0)">
            <summary>
            Return single sequence Immediately.
            </summary>
        </member>
        <member name="M:UniRx.Observable.Return``1(``0,UniRx.IScheduler)">
            <summary>
            Return single sequence on specified scheduler.
            </summary>
        </member>
        <member name="M:UniRx.Observable.Return(UniRx.Unit)">
            <summary>
            Return single sequence Immediately, optimized for Unit(no allocate memory).
            </summary>
        </member>
        <member name="M:UniRx.Observable.Return(System.Boolean)">
            <summary>
            Return single sequence Immediately, optimized for Boolean(no allocate memory).
            </summary>
        </member>
        <member name="M:UniRx.Observable.Return(System.Int32)">
            <summary>
            Return single sequence Immediately, optimized for Int32.
            </summary>
        </member>
        <member name="M:UniRx.Observable.ReturnUnit">
            <summary>
            Same as Observable.Return(Unit.Default); but no allocate memory.
            </summary>
        </member>
        <member name="M:UniRx.Observable.Throw``1(System.Exception)">
            <summary>
            Empty Observable. Returns only onError.
            </summary>
        </member>
        <member name="M:UniRx.Observable.Throw``1(System.Exception,``0)">
            <summary>
            Empty Observable. Returns only onError. witness if for Type inference.
            </summary>
        </member>
        <member name="M:UniRx.Observable.Throw``1(System.Exception,UniRx.IScheduler)">
            <summary>
            Empty Observable. Returns only onError on specified scheduler.
            </summary>
        </member>
        <member name="M:UniRx.Observable.Throw``1(System.Exception,UniRx.IScheduler,``0)">
            <summary>
            Empty Observable. Returns only onError on specified scheduler. witness if for Type inference.
            </summary>
        </member>
        <member name="M:UniRx.Observable.RepeatSafe``1(UniRx.IObservable{``0})">
            <summary>
            Same as Repeat() but if arriving contiguous "OnComplete" Repeat stops.
            </summary>
        </member>
        <member name="M:UniRx.Observable.ContinueWith``2(UniRx.IObservable{``0},UniRx.IObservable{``1})">
            <summary>
            Lightweight SelectMany for Single Async Operation.
            </summary>
        </member>
        <member name="M:UniRx.Observable.ContinueWith``2(UniRx.IObservable{``0},System.Func{``0,UniRx.IObservable{``1}})">
            <summary>
            Lightweight SelectMany for Single Async Operation.
            </summary>
        </member>
        <member name="M:UniRx.Observable.CatchIgnore``1(UniRx.IObservable{``0})">
            <summary>Catch exception and return Observable.Empty.</summary>
        </member>
        <member name="M:UniRx.Observable.CatchIgnore``2(UniRx.IObservable{``0},System.Action{``1})">
            <summary>Catch exception and return Observable.Empty.</summary>
        </member>
        <member name="M:UniRx.Observable.OnErrorRetry``1(UniRx.IObservable{``0})">
            <summary>
            <para>Repeats the source observable sequence until it successfully terminates.</para>
            <para>This is same as Retry().</para>
            </summary>
        </member>
        <member name="M:UniRx.Observable.OnErrorRetry``2(UniRx.IObservable{``0},System.Action{``1})">
            <summary>
            When catched exception, do onError action and repeat observable sequence.
            </summary>
        </member>
        <member name="M:UniRx.Observable.OnErrorRetry``2(UniRx.IObservable{``0},System.Action{``1},System.TimeSpan)">
            <summary>
            When catched exception, do onError action and repeat observable sequence after delay time.
            </summary>
        </member>
        <member name="M:UniRx.Observable.OnErrorRetry``2(UniRx.IObservable{``0},System.Action{``1},System.Int32)">
            <summary>
            When catched exception, do onError action and repeat observable sequence during within retryCount.
            </summary>
        </member>
        <member name="M:UniRx.Observable.OnErrorRetry``2(UniRx.IObservable{``0},System.Action{``1},System.Int32,System.TimeSpan)">
            <summary>
            When catched exception, do onError action and repeat observable sequence after delay time during within retryCount.
            </summary>
        </member>
        <member name="M:UniRx.Observable.OnErrorRetry``2(UniRx.IObservable{``0},System.Action{``1},System.Int32,System.TimeSpan,UniRx.IScheduler)">
            <summary>
            When catched exception, do onError action and repeat observable sequence after delay time(work on delayScheduler) during within retryCount.
            </summary>
        </member>
        <member name="M:UniRx.Observable.Pairwise``1(UniRx.IObservable{``0})">
            <summary>Projects old and new element of a sequence into a new form.</summary>
        </member>
        <member name="M:UniRx.Observable.Pairwise``2(UniRx.IObservable{``0},System.Func{``0,``0,``1})">
            <summary>Projects old and new element of a sequence into a new form.</summary>
        </member>
        <member name="M:UniRx.Observable.FromCoroutine(System.Func{System.Collections.IEnumerator},System.Boolean)">
            <summary>From has no callback coroutine to IObservable. If publishEveryYield = true then publish OnNext every yield return else return once on enumeration completed.</summary>
        </member>
        <member name="M:UniRx.Observable.FromCoroutine(System.Func{UniRx.CancellationToken,System.Collections.IEnumerator},System.Boolean)">
            <summary>From has no callback coroutine to IObservable. If publishEveryYield = true then publish OnNext every yield return else return once on enumeration completed.</summary>
        </member>
        <member name="M:UniRx.Observable.FromMicroCoroutine(System.Func{System.Collections.IEnumerator},System.Boolean,UniRx.FrameCountType)">
            <summary>
            MicroCoroutine is lightweight, fast coroutine dispatcher.
            IEnumerator supports only yield return null.
            If publishEveryYield = true then publish OnNext every yield return else return once on enumeration completed.
            </summary>
        </member>
        <member name="M:UniRx.Observable.FromMicroCoroutine(System.Func{UniRx.CancellationToken,System.Collections.IEnumerator},System.Boolean,UniRx.FrameCountType)">
            <summary>
            MicroCoroutine is lightweight, fast coroutine dispatcher.
            IEnumerator supports only yield return null.
            If publishEveryYield = true then publish OnNext every yield return else return once on enumeration completed.
            </summary>
        </member>
        <member name="M:UniRx.Observable.FromCoroutineValue``1(System.Func{System.Collections.IEnumerator},System.Boolean)">
            <summary>Convert coroutine to typed IObservable. If nullAsNextUpdate = true then yield return null when Enumerator.Current and no null publish observer.OnNext.</summary>
        </member>
        <member name="M:UniRx.Observable.FromCoroutineValue``1(System.Func{UniRx.CancellationToken,System.Collections.IEnumerator},System.Boolean)">
            <summary>Convert coroutine to typed IObservable. If nullAsNextUpdate = true then yield return null when Enumerator.Current and no null publish observer.OnNext.</summary>
        </member>
        <member name="M:UniRx.Observable.FromMicroCoroutine``1(System.Func{UniRx.IObserver{``0},System.Collections.IEnumerator},UniRx.FrameCountType)">
            <summary>
            MicroCoroutine is lightweight, fast coroutine dispatcher.
            IEnumerator supports only yield return null.
            </summary>
        </member>
        <member name="M:UniRx.Observable.FromMicroCoroutine``1(System.Func{UniRx.IObserver{``0},UniRx.CancellationToken,System.Collections.IEnumerator},UniRx.FrameCountType)">
            <summary>
            MicroCoroutine is lightweight, fast coroutine dispatcher.
            IEnumerator supports only yield return null.
            </summary>
        </member>
        <member name="M:UniRx.Observable.SelectMany``1(UniRx.IObservable{``0},System.Func{``0,System.Collections.IEnumerator})">
            <summary>
            Note: publishEveryYield is always false. If you want to set true, use Observable.FromCoroutine(() => selector(x), true). This is workaround of Unity compiler's bug.
            </summary>
        </member>
        <member name="M:UniRx.Observable.EveryUpdate">
            <summary>
            EveryUpdate calls coroutine's yield return null timing. It is after all Update and before LateUpdate.
            </summary>
        </member>
        <member name="M:UniRx.Observable.EveryGameObjectUpdate">
            <summary>
            EveryGameObjectUpdate calls from MainThreadDispatcher's Update.
            </summary>
        </member>
        <member name="M:UniRx.Observable.EveryLateUpdate">
            <summary>
            EveryLateUpdate calls from MainThreadDispatcher's OnLateUpdate.
            </summary>
        </member>
        <member name="M:UniRx.Observable.EveryAfterUpdate">
            <summary>
            [Obsolete]Same as EveryUpdate.
            </summary>
        </member>
        <member name="M:UniRx.Observable.ToYieldInstruction``1(UniRx.IObservable{``0})">
            <summary>
            Convert to yieldable IEnumerator. e.g. yield return source.ToYieldInstruction();.
            If needs last result, you can take ObservableYieldInstruction.HasResult/Result property.
            This overload throws exception if received OnError events(same as coroutine).
            </summary>
        </member>
        <member name="M:UniRx.Observable.ToYieldInstruction``1(UniRx.IObservable{``0},UniRx.CancellationToken)">
            <summary>
            Convert to yieldable IEnumerator. e.g. yield return source.ToYieldInstruction();.
            If needs last result, you can take ObservableYieldInstruction.HasResult/Result property.
            This overload throws exception if received OnError events(same as coroutine).
            </summary>
        </member>
        <member name="M:UniRx.Observable.ToYieldInstruction``1(UniRx.IObservable{``0},System.Boolean)">
            <summary>
            Convert to yieldable IEnumerator. e.g. yield return source.ToYieldInstruction();.
            If needs last result, you can take ObservableYieldInstruction.HasResult/Result property.
            If throwOnError = false, you can take ObservableYieldInstruction.HasError/Error property.
            </summary>
        </member>
        <member name="M:UniRx.Observable.ToYieldInstruction``1(UniRx.IObservable{``0},System.Boolean,UniRx.CancellationToken)">
            <summary>
            Convert to yieldable IEnumerator. e.g. yield return source.ToYieldInstruction();.
            If needs last result, you can take ObservableYieldInstruction.HasResult/Result property.
            If throwOnError = false, you can take ObservableYieldInstruction.HasError/Error property.
            </summary>
        </member>
        <member name="M:UniRx.Observable.ToAwaitableEnumerator``1(UniRx.IObservable{``0},UniRx.CancellationToken)">
            <summary>Convert to awaitable IEnumerator.</summary>
        </member>
        <member name="M:UniRx.Observable.ToAwaitableEnumerator``1(UniRx.IObservable{``0},System.Action{``0},UniRx.CancellationToken)">
            <summary>Convert to awaitable IEnumerator.</summary>
        </member>
        <member name="M:UniRx.Observable.ToAwaitableEnumerator``1(UniRx.IObservable{``0},System.Action{System.Exception},UniRx.CancellationToken)">
            <summary>Convert to awaitable IEnumerator.</summary>
        </member>
        <member name="M:UniRx.Observable.ToAwaitableEnumerator``1(UniRx.IObservable{``0},System.Action{``0},System.Action{System.Exception},UniRx.CancellationToken)">
            <summary>Convert to awaitable IEnumerator.</summary>
        </member>
        <member name="M:UniRx.Observable.StartAsCoroutine``1(UniRx.IObservable{``0},UniRx.CancellationToken)">
            <summary>AutoStart observable as coroutine.</summary>
        </member>
        <member name="M:UniRx.Observable.StartAsCoroutine``1(UniRx.IObservable{``0},System.Action{``0},UniRx.CancellationToken)">
            <summary>AutoStart observable as coroutine.</summary>
        </member>
        <member name="M:UniRx.Observable.StartAsCoroutine``1(UniRx.IObservable{``0},System.Action{System.Exception},UniRx.CancellationToken)">
            <summary>AutoStart observable as coroutine.</summary>
        </member>
        <member name="M:UniRx.Observable.StartAsCoroutine``1(UniRx.IObservable{``0},System.Action{``0},System.Action{System.Exception},UniRx.CancellationToken)">
            <summary>AutoStart observable as coroutine.</summary>
        </member>
        <member name="M:UniRx.Observable.OnceApplicationQuit">
            <summary>publish OnNext(Unit) and OnCompleted() on application quit.</summary>
        </member>
        <member name="M:UniRx.Observable.BatchFrame``1(UniRx.IObservable{``0})">
            <summary>
            Buffer elements in during target frame counts. Default raise same frame of end(frameCount = 0, frameCountType = EndOfFrame).
            </summary>
        </member>
        <member name="M:UniRx.Observable.BatchFrame``1(UniRx.IObservable{``0},System.Int32,UniRx.FrameCountType)">
            <summary>
            Buffer elements in during target frame counts.
            </summary>
        </member>
        <member name="M:UniRx.Observable.BatchFrame(UniRx.IObservable{UniRx.Unit})">
            <summary>
            Wait command in during target frame counts. Default raise same frame of end(frameCount = 0, frameCountType = EndOfFrame).
            </summary>
        </member>
        <member name="M:UniRx.Observable.BatchFrame(UniRx.IObservable{UniRx.Unit},System.Int32,UniRx.FrameCountType)">
            <summary>
            Wait command in during target frame counts.
            </summary>
        </member>
        <member name="T:UniRx.StableCompositeDisposable">
            <summary>
            Represents a group of disposable resources that are disposed together.
            </summary>
        </member>
        <member name="M:UniRx.StableCompositeDisposable.Create(System.IDisposable,System.IDisposable)">
            <summary>
            Creates a new group containing two disposable resources that are disposed together.
            </summary>
            <param name="disposable1">The first disposable resoruce to add to the group.</param>
            <param name="disposable2">The second disposable resoruce to add to the group.</param>
            <returns>Group of disposable resources that are disposed together.</returns>
        </member>
        <member name="M:UniRx.StableCompositeDisposable.Create(System.IDisposable,System.IDisposable,System.IDisposable)">
            <summary>
            Creates a new group containing three disposable resources that are disposed together.
            </summary>
            <param name="disposable1">The first disposable resoruce to add to the group.</param>
            <param name="disposable2">The second disposable resoruce to add to the group.</param>
            <param name="disposable3">The third disposable resoruce to add to the group.</param>
            <returns>Group of disposable resources that are disposed together.</returns>
        </member>
        <member name="M:UniRx.StableCompositeDisposable.Create(System.IDisposable,System.IDisposable,System.IDisposable,System.IDisposable)">
            <summary>
            Creates a new group containing four disposable resources that are disposed together.
            </summary>
            <param name="disposable1">The first disposable resoruce to add to the group.</param>
            <param name="disposable2">The second disposable resoruce to add to the group.</param>
            <param name="disposable3">The three disposable resoruce to add to the group.</param>
            <param name="disposable4">The four disposable resoruce to add to the group.</param>
            <returns>Group of disposable resources that are disposed together.</returns>
        </member>
        <member name="M:UniRx.StableCompositeDisposable.Create(System.IDisposable[])">
            <summary>
            Creates a new group of disposable resources that are disposed together.
            </summary>
            <param name="disposables">Disposable resources to add to the group.</param>
            <returns>Group of disposable resources that are disposed together.</returns>
        </member>
        <member name="M:UniRx.StableCompositeDisposable.CreateUnsafe(System.IDisposable[])">
            <summary>
            Creates a new group of disposable resources that are disposed together. Array is not copied, it's unsafe but optimized.
            </summary>
            <param name="disposables">Disposable resources to add to the group.</param>
            <returns>Group of disposable resources that are disposed together.</returns>
        </member>
        <member name="M:UniRx.StableCompositeDisposable.Create(System.Collections.Generic.IEnumerable{System.IDisposable})">
            <summary>
            Creates a new group of disposable resources that are disposed together.
            </summary>
            <param name="disposables">Disposable resources to add to the group.</param>
            <returns>Group of disposable resources that are disposed together.</returns>
        </member>
        <member name="M:UniRx.StableCompositeDisposable.Dispose">
            <summary>
            Disposes all disposables in the group.
            </summary>
        </member>
        <member name="P:UniRx.StableCompositeDisposable.IsDisposed">
            <summary>
            Gets a value that indicates whether the object is disposed.
            </summary>
        </member>
        <member name="T:UniRx.IEventPattern`2">
            <summary>
            Represents a .NET event invocation consisting of the strongly typed object that raised the event and the data that was generated by the event.
            </summary>
            <typeparam name="TSender">
            The type of the sender that raised the event.
            This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see Covariance and Contravariance in Generics.
            </typeparam>
            <typeparam name="TEventArgs">
            The type of the event data generated by the event.
            This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see Covariance and Contravariance in Generics.
            </typeparam>
        </member>
        <member name="P:UniRx.IEventPattern`2.Sender">
            <summary>
            Gets the sender object that raised the event.
            </summary>
        </member>
        <member name="P:UniRx.IEventPattern`2.EventArgs">
            <summary>
            Gets the event data that was generated by the event.
            </summary>
        </member>
        <member name="T:UniRx.EventPattern`1">
            <summary>
            Represents a .NET event invocation consisting of the weakly typed object that raised the event and the data that was generated by the event.
            </summary>
            <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
        </member>
        <member name="M:UniRx.EventPattern`1.#ctor(System.Object,`0)">
            <summary>
            Creates a new data representation instance of a .NET event invocation with the given sender and event data.
            </summary>
            <param name="sender">The sender object that raised the event.</param>
            <param name="e">The event data that was generated by the event.</param>
        </member>
        <member name="T:UniRx.EventPattern`2">
            <summary>
            Represents a .NET event invocation consisting of the strongly typed object that raised the event and the data that was generated by the event.
            </summary>
            <typeparam name="TSender">The type of the sender that raised the event.</typeparam>
            <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
        </member>
        <member name="M:UniRx.EventPattern`2.#ctor(`0,`1)">
            <summary>
            Creates a new data representation instance of a .NET event invocation with the given sender and event data.
            </summary>
            <param name="sender">The sender object that raised the event.</param>
            <param name="e">The event data that was generated by the event.</param>
        </member>
        <member name="P:UniRx.EventPattern`2.Sender">
            <summary>
            Gets the sender object that raised the event.
            </summary>
        </member>
        <member name="P:UniRx.EventPattern`2.EventArgs">
            <summary>
            Gets the event data that was generated by the event.
            </summary>
        </member>
        <member name="M:UniRx.EventPattern`2.Equals(UniRx.EventPattern{`0,`1})">
            <summary>
            Determines whether the current EventPattern&lt;TSender, TEventArgs&gt; object represents the same event as a specified EventPattern&lt;TSender, TEventArgs&gt; object.
            </summary>
            <param name="other">An object to compare to the current EventPattern&lt;TSender, TEventArgs&gt; object.</param>
            <returns>true if both EventPattern&lt;TSender, TEventArgs&gt; objects represent the same event; otherwise, false.</returns>
        </member>
        <member name="M:UniRx.EventPattern`2.Equals(System.Object)">
            <summary>
            Determines whether the specified System.Object is equal to the current EventPattern&lt;TSender, TEventArgs&gt;.
            </summary>
            <param name="obj">The System.Object to compare with the current EventPattern&lt;TSender, TEventArgs&gt;.</param>
            <returns>true if the specified System.Object is equal to the current EventPattern&lt;TSender, TEventArgs&gt;; otherwise, false.</returns>
        </member>
        <member name="M:UniRx.EventPattern`2.GetHashCode">
            <summary>
            Returns the hash code for the current EventPattern&lt;TSender, TEventArgs&gt; instance.
            </summary>
            <returns>A hash code for the current EventPattern&lt;TSender, TEventArgs&gt; instance.</returns>
        </member>
        <member name="M:UniRx.EventPattern`2.op_Equality(UniRx.EventPattern{`0,`1},UniRx.EventPattern{`0,`1})">
            <summary>
            Determines whether two specified EventPattern&lt;TSender, TEventArgs&gt; objects represent the same event.
            </summary>
            <param name="first">The first EventPattern&lt;TSender, TEventArgs&gt; to compare, or null.</param>
            <param name="second">The second EventPattern&lt;TSender, TEventArgs&gt; to compare, or null.</param>
            <returns>true if both EventPattern&lt;TSender, TEventArgs&gt; objects represent the same event; otherwise, false.</returns>
        </member>
        <member name="M:UniRx.EventPattern`2.op_Inequality(UniRx.EventPattern{`0,`1},UniRx.EventPattern{`0,`1})">
            <summary>
            Determines whether two specified EventPattern&lt;TSender, TEventArgs&gt; objects represent a different event.
            </summary>
            <param name="first">The first EventPattern&lt;TSender, TEventArgs&gt; to compare, or null.</param>
            <param name="second">The second EventPattern&lt;TSender, TEventArgs&gt; to compare, or null.</param>
            <returns>true if both EventPattern&lt;TSender, TEventArgs&gt; objects don't represent the same event; otherwise, false.</returns>
        </member>
        <member name="T:UniRx.InternalUtil.AsyncLock">
            <summary>
            Asynchronous lock.
            </summary>
        </member>
        <member name="M:UniRx.InternalUtil.AsyncLock.Wait(System.Action)">
            <summary>
            Queues the action for execution. If the caller acquires the lock and becomes the owner,
            the queue is processed. If the lock is already owned, the action is queued and will get
            processed by the owner.
            </summary>
            <param name="action">Action to queue for execution.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> is null.</exception>
        </member>
        <member name="M:UniRx.InternalUtil.AsyncLock.Dispose">
            <summary>
            Clears the work items in the queue and drops further work being queued.
            </summary>
        </member>
        <member name="T:UniRx.InternalUtil.MicroCoroutine">
            <summary>
            Simple supports(only yield return null) lightweight, threadsafe coroutine dispatcher.
            </summary>
        </member>
        <member name="T:UniRx.InternalUtil.ScheduledItem">
            <summary>
            Abstract base class for scheduled work items.
            </summary>
        </member>
        <member name="M:UniRx.InternalUtil.ScheduledItem.#ctor(System.Action,System.TimeSpan)">
            <summary>
            Creates a new scheduled work item to run at the specified time.
            </summary>
            <param name="dueTime">Absolute time at which the work item has to be executed.</param>
        </member>
        <member name="P:UniRx.InternalUtil.ScheduledItem.DueTime">
            <summary>
            Gets the absolute time at which the item is due for invocation.
            </summary>
        </member>
        <member name="M:UniRx.InternalUtil.ScheduledItem.Invoke">
            <summary>
            Invokes the work item.
            </summary>
        </member>
        <member name="M:UniRx.InternalUtil.ScheduledItem.CompareTo(UniRx.InternalUtil.ScheduledItem)">
            <summary>
            Compares the work item with another work item based on absolute time values.
            </summary>
            <param name="other">Work item to compare the current work item to.</param>
            <returns>Relative ordering between this and the specified work item.</returns>
            <remarks>The inequality operators are overloaded to provide results consistent with the IComparable implementation. Equality operators implement traditional reference equality semantics.</remarks>
        </member>
        <member name="M:UniRx.InternalUtil.ScheduledItem.op_LessThan(UniRx.InternalUtil.ScheduledItem,UniRx.InternalUtil.ScheduledItem)">
            <summary>
            Determines whether one specified ScheduledItem&lt;TAbsolute&gt; object is due before a second specified ScheduledItem&lt;TAbsolute&gt; object.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>true if the DueTime value of left is earlier than the DueTime value of right; otherwise, false.</returns>
            <remarks>This operator provides results consistent with the IComparable implementation.</remarks>
        </member>
        <member name="M:UniRx.InternalUtil.ScheduledItem.op_LessThanOrEqual(UniRx.InternalUtil.ScheduledItem,UniRx.InternalUtil.ScheduledItem)">
            <summary>
            Determines whether one specified ScheduledItem&lt;TAbsolute&gt; object is due before or at the same of a second specified ScheduledItem&lt;TAbsolute&gt; object.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>true if the DueTime value of left is earlier than or simultaneous with the DueTime value of right; otherwise, false.</returns>
            <remarks>This operator provides results consistent with the IComparable implementation.</remarks>
        </member>
        <member name="M:UniRx.InternalUtil.ScheduledItem.op_GreaterThan(UniRx.InternalUtil.ScheduledItem,UniRx.InternalUtil.ScheduledItem)">
            <summary>
            Determines whether one specified ScheduledItem&lt;TAbsolute&gt; object is due after a second specified ScheduledItem&lt;TAbsolute&gt; object.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>true if the DueTime value of left is later than the DueTime value of right; otherwise, false.</returns>
            <remarks>This operator provides results consistent with the IComparable implementation.</remarks>
        </member>
        <member name="M:UniRx.InternalUtil.ScheduledItem.op_GreaterThanOrEqual(UniRx.InternalUtil.ScheduledItem,UniRx.InternalUtil.ScheduledItem)">
            <summary>
            Determines whether one specified ScheduledItem&lt;TAbsolute&gt; object is due after or at the same time of a second specified ScheduledItem&lt;TAbsolute&gt; object.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>true if the DueTime value of left is later than or simultaneous with the DueTime value of right; otherwise, false.</returns>
            <remarks>This operator provides results consistent with the IComparable implementation.</remarks>
        </member>
        <member name="M:UniRx.InternalUtil.ScheduledItem.op_Equality(UniRx.InternalUtil.ScheduledItem,UniRx.InternalUtil.ScheduledItem)">
            <summary>
            Determines whether two specified ScheduledItem&lt;TAbsolute, TValue&gt; objects are equal.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>true if both ScheduledItem&lt;TAbsolute, TValue&gt; are equal; otherwise, false.</returns>
            <remarks>This operator does not provide results consistent with the IComparable implementation. Instead, it implements reference equality.</remarks>
        </member>
        <member name="M:UniRx.InternalUtil.ScheduledItem.op_Inequality(UniRx.InternalUtil.ScheduledItem,UniRx.InternalUtil.ScheduledItem)">
            <summary>
            Determines whether two specified ScheduledItem&lt;TAbsolute, TValue&gt; objects are inequal.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>true if both ScheduledItem&lt;TAbsolute, TValue&gt; are inequal; otherwise, false.</returns>
            <remarks>This operator does not provide results consistent with the IComparable implementation. Instead, it implements reference equality.</remarks>
        </member>
        <member name="M:UniRx.InternalUtil.ScheduledItem.Equals(System.Object)">
            <summary>
            Determines whether a ScheduledItem&lt;TAbsolute&gt; object is equal to the specified object.
            </summary>
            <param name="obj">The object to compare to the current ScheduledItem&lt;TAbsolute&gt; object.</param>
            <returns>true if the obj parameter is a ScheduledItem&lt;TAbsolute&gt; object and is equal to the current ScheduledItem&lt;TAbsolute&gt; object; otherwise, false.</returns>
        </member>
        <member name="M:UniRx.InternalUtil.ScheduledItem.GetHashCode">
            <summary>
            Returns the hash code for the current ScheduledItem&lt;TAbsolute&gt; object.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="P:UniRx.InternalUtil.ScheduledItem.IsCanceled">
            <summary>
            Gets whether the work item has received a cancellation request.
            </summary>
        </member>
        <member name="T:UniRx.InternalUtil.SchedulerQueue">
            <summary>
            Efficient scheduler queue that maintains scheduled items sorted by absolute time.
            </summary>
            <remarks>This type is not thread safe; users should ensure proper synchronization.</remarks>
        </member>
        <member name="M:UniRx.InternalUtil.SchedulerQueue.#ctor">
            <summary>
            Creates a new scheduler queue with a default initial capacity.
            </summary>
        </member>
        <member name="M:UniRx.InternalUtil.SchedulerQueue.#ctor(System.Int32)">
            <summary>
            Creats a new scheduler queue with the specified initial capacity.
            </summary>
            <param name="capacity">Initial capacity of the scheduler queue.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> is less than zero.</exception>
        </member>
        <member name="P:UniRx.InternalUtil.SchedulerQueue.Count">
            <summary>
            Gets the number of scheduled items in the scheduler queue.
            </summary>
        </member>
        <member name="M:UniRx.InternalUtil.SchedulerQueue.Enqueue(UniRx.InternalUtil.ScheduledItem)">
            <summary>
            Enqueues the specified work item to be scheduled.
            </summary>
            <param name="scheduledItem">Work item to be scheduled.</param>
        </member>
        <member name="M:UniRx.InternalUtil.SchedulerQueue.Remove(UniRx.InternalUtil.ScheduledItem)">
            <summary>
            Removes the specified work item from the scheduler queue.
            </summary>
            <param name="scheduledItem">Work item to be removed from the scheduler queue.</param>
            <returns>true if the item was found; false otherwise.</returns>
        </member>
        <member name="M:UniRx.InternalUtil.SchedulerQueue.Dequeue">
            <summary>
            Dequeues the next work item from the scheduler queue.
            </summary>
            <returns>Next work item in the scheduler queue (removed).</returns>
        </member>
        <member name="M:UniRx.InternalUtil.SchedulerQueue.Peek">
            <summary>
            Peeks the next work item in the scheduler queue.
            </summary>
            <returns>Next work item in the scheduler queue (not removed).</returns>
        </member>
        <member name="T:UniRx.IObserver`2">
            <summary>
            Provides a mechanism for receiving push-based notifications and returning a response.
            </summary>
            <typeparam name="TValue">
            The type of the elements received by the observer.
            This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see Covariance and Contravariance in Generics.
            </typeparam>
            <typeparam name="TResult">
            The type of the result returned from the observer's notification handlers.
            This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see Covariance and Contravariance in Generics.
            </typeparam>
        </member>
        <member name="M:UniRx.IObserver`2.OnNext(`0)">
            <summary>
            Notifies the observer of a new element in the sequence.
            </summary>
            <param name="value">The new element in the sequence.</param>
            <returns>Result returned upon observation of a new element.</returns>
        </member>
        <member name="M:UniRx.IObserver`2.OnError(System.Exception)">
            <summary>
            Notifies the observer that an exception has occurred.
            </summary>
            <param name="exception">The exception that occurred.</param>
            <returns>Result returned upon observation of an error.</returns>
        </member>
        <member name="M:UniRx.IObserver`2.OnCompleted">
            <summary>
            Notifies the observer of the end of the sequence.
            </summary>
            <returns>Result returned upon observation of the sequence completion.</returns>
        </member>
        <member name="T:UniRx.NotificationKind">
            <summary>
            Indicates the type of a notification.
            </summary>
        </member>
        <member name="F:UniRx.NotificationKind.OnNext">
            <summary>
            Represents an OnNext notification.
            </summary>
        </member>
        <member name="F:UniRx.NotificationKind.OnError">
            <summary>
            Represents an OnError notification.
            </summary>
        </member>
        <member name="F:UniRx.NotificationKind.OnCompleted">
            <summary>
            Represents an OnCompleted notification.
            </summary>
        </member>
        <member name="T:UniRx.Notification`1">
            <summary>
            Represents a notification to an observer.
            </summary>
            <typeparam name="T">The type of the elements received by the observer.</typeparam>
        </member>
        <member name="M:UniRx.Notification`1.#ctor">
            <summary>
            Default constructor used by derived types.
            </summary>
        </member>
        <member name="P:UniRx.Notification`1.Value">
            <summary>
            Returns the value of an OnNext notification or throws an exception.
            </summary>
        </member>
        <member name="P:UniRx.Notification`1.HasValue">
            <summary>
            Returns a value that indicates whether the notification has a value.
            </summary>
        </member>
        <member name="P:UniRx.Notification`1.Exception">
            <summary>
            Returns the exception of an OnError notification or returns null.
            </summary>
        </member>
        <member name="P:UniRx.Notification`1.Kind">
            <summary>
            Gets the kind of notification that is represented.
            </summary>
        </member>
        <member name="T:UniRx.Notification`1.OnNextNotification">
            <summary>
            Represents an OnNext notification to an observer.
            </summary>
        </member>
        <member name="M:UniRx.Notification`1.OnNextNotification.#ctor(`0)">
            <summary>
            Constructs a notification of a new value.
            </summary>
        </member>
        <member name="P:UniRx.Notification`1.OnNextNotification.Value">
            <summary>
            Returns the value of an OnNext notification.
            </summary>
        </member>
        <member name="P:UniRx.Notification`1.OnNextNotification.Exception">
            <summary>
            Returns null.
            </summary>
        </member>
        <member name="P:UniRx.Notification`1.OnNextNotification.HasValue">
            <summary>
            Returns true.
            </summary>
        </member>
        <member name="P:UniRx.Notification`1.OnNextNotification.Kind">
            <summary>
            Returns NotificationKind.OnNext.
            </summary>
        </member>
        <member name="M:UniRx.Notification`1.OnNextNotification.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
        </member>
        <member name="M:UniRx.Notification`1.OnNextNotification.Equals(UniRx.Notification{`0})">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
        </member>
        <member name="M:UniRx.Notification`1.OnNextNotification.ToString">
            <summary>
            Returns a string representation of this instance.
            </summary>
        </member>
        <member name="M:UniRx.Notification`1.OnNextNotification.Accept(UniRx.IObserver{`0})">
            <summary>
            Invokes the observer's method corresponding to the notification.
            </summary>
            <param name="observer">Observer to invoke the notification on.</param>
        </member>
        <member name="M:UniRx.Notification`1.OnNextNotification.Accept``1(UniRx.IObserver{`0,``0})">
            <summary>
            Invokes the observer's method corresponding to the notification and returns the produced result.
            </summary>
            <param name="observer">Observer to invoke the notification on.</param>
            <returns>Result produced by the observation.</returns>
        </member>
        <member name="M:UniRx.Notification`1.OnNextNotification.Accept(System.Action{`0},System.Action{System.Exception},System.Action)">
            <summary>
            Invokes the delegate corresponding to the notification.
            </summary>
            <param name="onNext">Delegate to invoke for an OnNext notification.</param>
            <param name="onError">Delegate to invoke for an OnError notification.</param>
            <param name="onCompleted">Delegate to invoke for an OnCompleted notification.</param>
        </member>
        <member name="M:UniRx.Notification`1.OnNextNotification.Accept``1(System.Func{`0,``0},System.Func{System.Exception,``0},System.Func{``0})">
            <summary>
            Invokes the delegate corresponding to the notification and returns the produced result.
            </summary>
            <param name="onNext">Delegate to invoke for an OnNext notification.</param>
            <param name="onError">Delegate to invoke for an OnError notification.</param>
            <param name="onCompleted">Delegate to invoke for an OnCompleted notification.</param>
            <returns>Result produced by the observation.</returns>
        </member>
        <member name="T:UniRx.Notification`1.OnErrorNotification">
            <summary>
            Represents an OnError notification to an observer.
            </summary>
        </member>
        <member name="M:UniRx.Notification`1.OnErrorNotification.#ctor(System.Exception)">
            <summary>
            Constructs a notification of an exception.
            </summary>
        </member>
        <member name="P:UniRx.Notification`1.OnErrorNotification.Value">
            <summary>
            Throws the exception.
            </summary>
        </member>
        <member name="P:UniRx.Notification`1.OnErrorNotification.Exception">
            <summary>
            Returns the exception.
            </summary>
        </member>
        <member name="P:UniRx.Notification`1.OnErrorNotification.HasValue">
            <summary>
            Returns false.
            </summary>
        </member>
        <member name="P:UniRx.Notification`1.OnErrorNotification.Kind">
            <summary>
            Returns NotificationKind.OnError.
            </summary>
        </member>
        <member name="M:UniRx.Notification`1.OnErrorNotification.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
        </member>
        <member name="M:UniRx.Notification`1.OnErrorNotification.Equals(UniRx.Notification{`0})">
            <summary>
            Indicates whether this instance and other are equal.
            </summary>
        </member>
        <member name="M:UniRx.Notification`1.OnErrorNotification.ToString">
            <summary>
            Returns a string representation of this instance.
            </summary>
        </member>
        <member name="M:UniRx.Notification`1.OnErrorNotification.Accept(UniRx.IObserver{`0})">
            <summary>
            Invokes the observer's method corresponding to the notification.
            </summary>
            <param name="observer">Observer to invoke the notification on.</param>
        </member>
        <member name="M:UniRx.Notification`1.OnErrorNotification.Accept``1(UniRx.IObserver{`0,``0})">
            <summary>
            Invokes the observer's method corresponding to the notification and returns the produced result.
            </summary>
            <param name="observer">Observer to invoke the notification on.</param>
            <returns>Result produced by the observation.</returns>
        </member>
        <member name="M:UniRx.Notification`1.OnErrorNotification.Accept(System.Action{`0},System.Action{System.Exception},System.Action)">
            <summary>
            Invokes the delegate corresponding to the notification.
            </summary>
            <param name="onNext">Delegate to invoke for an OnNext notification.</param>
            <param name="onError">Delegate to invoke for an OnError notification.</param>
            <param name="onCompleted">Delegate to invoke for an OnCompleted notification.</param>
        </member>
        <member name="M:UniRx.Notification`1.OnErrorNotification.Accept``1(System.Func{`0,``0},System.Func{System.Exception,``0},System.Func{``0})">
            <summary>
            Invokes the delegate corresponding to the notification and returns the produced result.
            </summary>
            <param name="onNext">Delegate to invoke for an OnNext notification.</param>
            <param name="onError">Delegate to invoke for an OnError notification.</param>
            <param name="onCompleted">Delegate to invoke for an OnCompleted notification.</param>
            <returns>Result produced by the observation.</returns>
        </member>
        <member name="T:UniRx.Notification`1.OnCompletedNotification">
            <summary>
            Represents an OnCompleted notification to an observer.
            </summary>
        </member>
        <member name="M:UniRx.Notification`1.OnCompletedNotification.#ctor">
            <summary>
            Constructs a notification of the end of a sequence.
            </summary>
        </member>
        <member name="P:UniRx.Notification`1.OnCompletedNotification.Value">
            <summary>
            Throws an InvalidOperationException.
            </summary>
        </member>
        <member name="P:UniRx.Notification`1.OnCompletedNotification.Exception">
            <summary>
            Returns null.
            </summary>
        </member>
        <member name="P:UniRx.Notification`1.OnCompletedNotification.HasValue">
            <summary>
            Returns false.
            </summary>
        </member>
        <member name="P:UniRx.Notification`1.OnCompletedNotification.Kind">
            <summary>
            Returns NotificationKind.OnCompleted.
            </summary>
        </member>
        <member name="M:UniRx.Notification`1.OnCompletedNotification.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
        </member>
        <member name="M:UniRx.Notification`1.OnCompletedNotification.Equals(UniRx.Notification{`0})">
            <summary>
            Indicates whether this instance and other are equal.
            </summary>
        </member>
        <member name="M:UniRx.Notification`1.OnCompletedNotification.ToString">
            <summary>
            Returns a string representation of this instance.
            </summary>
        </member>
        <member name="M:UniRx.Notification`1.OnCompletedNotification.Accept(UniRx.IObserver{`0})">
            <summary>
            Invokes the observer's method corresponding to the notification.
            </summary>
            <param name="observer">Observer to invoke the notification on.</param>
        </member>
        <member name="M:UniRx.Notification`1.OnCompletedNotification.Accept``1(UniRx.IObserver{`0,``0})">
            <summary>
            Invokes the observer's method corresponding to the notification and returns the produced result.
            </summary>
            <param name="observer">Observer to invoke the notification on.</param>
            <returns>Result produced by the observation.</returns>
        </member>
        <member name="M:UniRx.Notification`1.OnCompletedNotification.Accept(System.Action{`0},System.Action{System.Exception},System.Action)">
            <summary>
            Invokes the delegate corresponding to the notification.
            </summary>
            <param name="onNext">Delegate to invoke for an OnNext notification.</param>
            <param name="onError">Delegate to invoke for an OnError notification.</param>
            <param name="onCompleted">Delegate to invoke for an OnCompleted notification.</param>
        </member>
        <member name="M:UniRx.Notification`1.OnCompletedNotification.Accept``1(System.Func{`0,``0},System.Func{System.Exception,``0},System.Func{``0})">
            <summary>
            Invokes the delegate corresponding to the notification and returns the produced result.
            </summary>
            <param name="onNext">Delegate to invoke for an OnNext notification.</param>
            <param name="onError">Delegate to invoke for an OnError notification.</param>
            <param name="onCompleted">Delegate to invoke for an OnCompleted notification.</param>
            <returns>Result produced by the observation.</returns>
        </member>
        <member name="M:UniRx.Notification`1.Equals(UniRx.Notification{`0})">
            <summary>
            Determines whether the current Notification&lt;T&gt; object has the same observer message payload as a specified Notification&lt;T&gt; value.
            </summary>
            <param name="other">An object to compare to the current Notification&lt;T&gt; object.</param>
            <returns>true if both Notification&lt;T&gt; objects have the same observer message payload; otherwise, false.</returns>
            <remarks>
            Equality of Notification&lt;T&gt; objects is based on the equality of the observer message payload they represent, including the notification Kind and the Value or Exception (if any).
            This means two Notification&lt;T&gt; objects can be equal even though they don't represent the same observer method call, but have the same Kind and have equal parameters passed to the observer method.
            In case one wants to determine whether two Notification&lt;T&gt; objects represent the same observer method call, use Object.ReferenceEquals identity equality instead.
            </remarks>
        </member>
        <member name="M:UniRx.Notification`1.op_Equality(UniRx.Notification{`0},UniRx.Notification{`0})">
            <summary>
            Determines whether the two specified Notification&lt;T&gt; objects have the same observer message payload.
            </summary>
            <param name="left">The first Notification&lt;T&gt; to compare, or null.</param>
            <param name="right">The second Notification&lt;T&gt; to compare, or null.</param>
            <returns>true if the first Notification&lt;T&gt; value has the same observer message payload as the second Notification&lt;T&gt; value; otherwise, false.</returns>
            <remarks>
            Equality of Notification&lt;T&gt; objects is based on the equality of the observer message payload they represent, including the notification Kind and the Value or Exception (if any).
            This means two Notification&lt;T&gt; objects can be equal even though they don't represent the same observer method call, but have the same Kind and have equal parameters passed to the observer method.
            In case one wants to determine whether two Notification&lt;T&gt; objects represent the same observer method call, use Object.ReferenceEquals identity equality instead.
            </remarks>
        </member>
        <member name="M:UniRx.Notification`1.op_Inequality(UniRx.Notification{`0},UniRx.Notification{`0})">
            <summary>
            Determines whether the two specified Notification&lt;T&gt; objects have a different observer message payload.
            </summary>
            <param name="left">The first Notification&lt;T&gt; to compare, or null.</param>
            <param name="right">The second Notification&lt;T&gt; to compare, or null.</param>
            <returns>true if the first Notification&lt;T&gt; value has a different observer message payload as the second Notification&lt;T&gt; value; otherwise, false.</returns>
            <remarks>
            Equality of Notification&lt;T&gt; objects is based on the equality of the observer message payload they represent, including the notification Kind and the Value or Exception (if any).
            This means two Notification&lt;T&gt; objects can be equal even though they don't represent the same observer method call, but have the same Kind and have equal parameters passed to the observer method.
            In case one wants to determine whether two Notification&lt;T&gt; objects represent a different observer method call, use Object.ReferenceEquals identity equality instead.
            </remarks>
        </member>
        <member name="M:UniRx.Notification`1.Equals(System.Object)">
            <summary>
            Determines whether the specified System.Object is equal to the current Notification&lt;T&gt;.
            </summary>
            <param name="obj">The System.Object to compare with the current Notification&lt;T&gt;.</param>
            <returns>true if the specified System.Object is equal to the current Notification&lt;T&gt;; otherwise, false.</returns>
            <remarks>
            Equality of Notification&lt;T&gt; objects is based on the equality of the observer message payload they represent, including the notification Kind and the Value or Exception (if any).
            This means two Notification&lt;T&gt; objects can be equal even though they don't represent the same observer method call, but have the same Kind and have equal parameters passed to the observer method.
            In case one wants to determine whether two Notification&lt;T&gt; objects represent the same observer method call, use Object.ReferenceEquals identity equality instead.
            </remarks>
        </member>
        <member name="M:UniRx.Notification`1.Accept(UniRx.IObserver{`0})">
            <summary>
            Invokes the observer's method corresponding to the notification.
            </summary>
            <param name="observer">Observer to invoke the notification on.</param>
        </member>
        <member name="M:UniRx.Notification`1.Accept``1(UniRx.IObserver{`0,``0})">
            <summary>
            Invokes the observer's method corresponding to the notification and returns the produced result.
            </summary>
            <typeparam name="TResult">The type of the result returned from the observer's notification handlers.</typeparam>
            <param name="observer">Observer to invoke the notification on.</param>
            <returns>Result produced by the observation.</returns>
        </member>
        <member name="M:UniRx.Notification`1.Accept(System.Action{`0},System.Action{System.Exception},System.Action)">
            <summary>
            Invokes the delegate corresponding to the notification.
            </summary>
            <param name="onNext">Delegate to invoke for an OnNext notification.</param>
            <param name="onError">Delegate to invoke for an OnError notification.</param>
            <param name="onCompleted">Delegate to invoke for an OnCompleted notification.</param>
        </member>
        <member name="M:UniRx.Notification`1.Accept``1(System.Func{`0,``0},System.Func{System.Exception,``0},System.Func{``0})">
            <summary>
            Invokes the delegate corresponding to the notification and returns the produced result.
            </summary>
            <typeparam name="TResult">The type of the result returned from the notification handler delegates.</typeparam>
            <param name="onNext">Delegate to invoke for an OnNext notification.</param>
            <param name="onError">Delegate to invoke for an OnError notification.</param>
            <param name="onCompleted">Delegate to invoke for an OnCompleted notification.</param>
            <returns>Result produced by the observation.</returns>
        </member>
        <member name="M:UniRx.Notification`1.ToObservable">
            <summary>
            Returns an observable sequence with a single notification, using the immediate scheduler.
            </summary>
            <returns>The observable sequence that surfaces the behavior of the notification upon subscription.</returns>
        </member>
        <member name="M:UniRx.Notification`1.ToObservable(UniRx.IScheduler)">
            <summary>
            Returns an observable sequence with a single notification.
            </summary>
            <param name="scheduler">Scheduler to send out the notification calls on.</param>
            <returns>The observable sequence that surfaces the behavior of the notification upon subscription.</returns>
        </member>
        <member name="T:UniRx.Notification">
            <summary>
            Provides a set of static methods for constructing notifications.
            </summary>
        </member>
        <member name="M:UniRx.Notification.CreateOnNext``1(``0)">
            <summary>
            Creates an object that represents an OnNext notification to an observer.
            </summary>
            <typeparam name="T">The type of the elements received by the observer. Upon dematerialization of the notifications into an observable sequence, this type is used as the element type for the sequence.</typeparam>
            <param name="value">The value contained in the notification.</param>
            <returns>The OnNext notification containing the value.</returns>
        </member>
        <member name="M:UniRx.Notification.CreateOnError``1(System.Exception)">
            <summary>
            Creates an object that represents an OnError notification to an observer.
            </summary>
            <typeparam name="T">The type of the elements received by the observer. Upon dematerialization of the notifications into an observable sequence, this type is used as the element type for the sequence.</typeparam>
            <param name="error">The exception contained in the notification.</param>
            <returns>The OnError notification containing the exception.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="error"/> is null.</exception>
        </member>
        <member name="M:UniRx.Notification.CreateOnCompleted``1">
            <summary>
            Creates an object that represents an OnCompleted notification to an observer.
            </summary>
            <typeparam name="T">The type of the elements received by the observer. Upon dematerialization of the notifications into an observable sequence, this type is used as the element type for the sequence.</typeparam>
            <returns>The OnCompleted notification.</returns>
        </member>
        <member name="T:UniRx.BooleanNotifier">
            <summary>
            Notify boolean flag.
            </summary>
        </member>
        <member name="P:UniRx.BooleanNotifier.Value">
            <summary>Current flag value</summary>
        </member>
        <member name="M:UniRx.BooleanNotifier.#ctor(System.Boolean)">
            <summary>
            Setup initial flag.
            </summary>
        </member>
        <member name="M:UniRx.BooleanNotifier.TurnOn">
            <summary>
            Set and raise true if current value isn't true.
            </summary>
        </member>
        <member name="M:UniRx.BooleanNotifier.TurnOff">
            <summary>
            Set and raise false if current value isn't false.
            </summary>
        </member>
        <member name="M:UniRx.BooleanNotifier.SwitchValue">
            <summary>
            Set and raise reverse value.
            </summary>
        </member>
        <member name="M:UniRx.BooleanNotifier.Subscribe(UniRx.IObserver{System.Boolean})">
            <summary>
            Subscribe observer.
            </summary>
        </member>
        <member name="T:UniRx.CountChangedStatus">
            <summary>Event kind of CountNotifier.</summary>
        </member>
        <member name="F:UniRx.CountChangedStatus.Increment">
            <summary>Count incremented.</summary>
        </member>
        <member name="F:UniRx.CountChangedStatus.Decrement">
            <summary>Count decremented.</summary>
        </member>
        <member name="F:UniRx.CountChangedStatus.Empty">
            <summary>Count is zero.</summary>
        </member>
        <member name="F:UniRx.CountChangedStatus.Max">
            <summary>Count arrived max.</summary>
        </member>
        <member name="T:UniRx.CountNotifier">
            <summary>
            Notify event of count flag.
            </summary>
        </member>
        <member name="M:UniRx.CountNotifier.#ctor(System.Int32)">
            <summary>
            Setup max count of signal.
            </summary>
        </member>
        <member name="M:UniRx.CountNotifier.Increment(System.Int32)">
            <summary>
            Increment count and notify status.
            </summary>
        </member>
        <member name="M:UniRx.CountNotifier.Decrement(System.Int32)">
            <summary>
            Decrement count and notify status.
            </summary>
        </member>
        <member name="M:UniRx.CountNotifier.Subscribe(UniRx.IObserver{UniRx.CountChangedStatus})">
            <summary>
            Subscribe observer.
            </summary>
        </member>
        <member name="M:UniRx.IMessagePublisher.Publish``1(``0)">
            <summary>
            Send Message to all receiver.
            </summary>
        </member>
        <member name="M:UniRx.IMessageReceiver.Receive``1">
            <summary>
            Subscribe typed message.
            </summary>
        </member>
        <member name="M:UniRx.IAsyncMessagePublisher.PublishAsync``1(``0)">
            <summary>
            Send Message to all receiver and await complete.
            </summary>
        </member>
        <member name="M:UniRx.IAsyncMessageReceiver.Subscribe``1(System.Func{``0,UniRx.IObservable{UniRx.Unit}})">
            <summary>
            Subscribe typed message.
            </summary>
        </member>
        <member name="T:UniRx.MessageBroker">
            <summary>
            In-Memory PubSub filtered by Type.
            </summary>
        </member>
        <member name="F:UniRx.MessageBroker.Default">
            <summary>
            MessageBroker in Global scope.
            </summary>
        </member>
        <member name="T:UniRx.AsyncMessageBroker">
            <summary>
            In-Memory PubSub filtered by Type.
            </summary>
        </member>
        <member name="F:UniRx.AsyncMessageBroker.Default">
            <summary>
            AsyncMessageBroker in Global scope.
            </summary>
        </member>
        <member name="T:UniRx.ScheduledNotifier`1">
            <summary>
            Notify value on setuped scheduler.
            </summary>
        </member>
        <member name="M:UniRx.ScheduledNotifier`1.#ctor">
            <summary>
            Use scheduler is Scheduler.DefaultSchedulers.ConstantTimeOperations.
            </summary>
        </member>
        <member name="M:UniRx.ScheduledNotifier`1.#ctor(UniRx.IScheduler)">
            <summary>
            Use scheduler is argument's scheduler.
            </summary>
        </member>
        <member name="M:UniRx.ScheduledNotifier`1.Report(`0)">
            <summary>
            Push value to subscribers on setuped scheduler.
            </summary>
        </member>
        <member name="M:UniRx.ScheduledNotifier`1.Report(`0,System.TimeSpan)">
            <summary>
            Push value to subscribers on setuped scheduler.
            </summary>
        </member>
        <member name="M:UniRx.ScheduledNotifier`1.Report(`0,System.DateTimeOffset)">
            <summary>
            Push value to subscribers on setuped scheduler.
            </summary>
        </member>
        <member name="M:UniRx.ScheduledNotifier`1.Subscribe(UniRx.IObserver{`0})">
            <summary>
            Subscribe observer.
            </summary>
        </member>
        <member name="T:UniRx.Scheduler.CurrentThreadScheduler">
            <summary>
            Represents an object that schedules units of work on the current thread.
            </summary>
            <seealso cref="F:UniRx.Scheduler.CurrentThread">Singleton instance of this type exposed through this static property.</seealso>
        </member>
        <member name="P:UniRx.Scheduler.CurrentThreadScheduler.IsScheduleRequired">
            <summary>
            Gets a value that indicates whether the caller must call a Schedule method.
            </summary>
        </member>
        <member name="P:UniRx.Scheduler.MainThread">
            <summary>
            Unity native MainThread Queue Scheduler. Run on mainthread and delayed on coroutine update loop, elapsed time is calculated based on Time.time.
            </summary>
        </member>
        <member name="P:UniRx.Scheduler.MainThreadIgnoreTimeScale">
            <summary>
            Another MainThread scheduler, delay elapsed time is calculated based on Time.unscaledDeltaTime.
            </summary>
        </member>
        <member name="P:UniRx.Scheduler.MainThreadFixedUpdate">
            <summary>
            Run on fixed update mainthread, delay elapsed time is calculated based on Time.fixedTime.
            </summary>
        </member>
        <member name="P:UniRx.Scheduler.MainThreadEndOfFrame">
            <summary>
            Run on end of frame mainthread, delay elapsed time is calculated based on Time.deltaTime.
            </summary>
        </member>
        <member name="T:UniRx.TimeInterval`1">
            <summary>
            Represents a value associated with time interval information.
            The time interval can represent the time it took to produce the value, the interval relative to a previous value, the value's delivery time relative to a base, etc.
            </summary>
            <typeparam name="T">The type of the value being annotated with time interval information.</typeparam>
        </member>
        <member name="M:UniRx.TimeInterval`1.#ctor(`0,System.TimeSpan)">
            <summary>
            Constructs a time interval value.
            </summary>
            <param name="value">The value to be annotated with a time interval.</param>
            <param name="interval">Time interval associated with the value.</param>
        </member>
        <member name="P:UniRx.TimeInterval`1.Value">
            <summary>
            Gets the value.
            </summary>
        </member>
        <member name="P:UniRx.TimeInterval`1.Interval">
            <summary>
            Gets the interval.
            </summary>
        </member>
        <member name="M:UniRx.TimeInterval`1.Equals(UniRx.TimeInterval{`0})">
            <summary>
            Determines whether the current TimeInterval&lt;T&gt; value has the same Value and Interval as a specified TimeInterval&lt;T&gt; value.
            </summary>
            <param name="other">An object to compare to the current TimeInterval&lt;T&gt; value.</param>
            <returns>true if both TimeInterval&lt;T&gt; values have the same Value and Interval; otherwise, false.</returns>
        </member>
        <member name="M:UniRx.TimeInterval`1.op_Equality(UniRx.TimeInterval{`0},UniRx.TimeInterval{`0})">
            <summary>
            Determines whether the two specified TimeInterval&lt;T&gt; values have the same Value and Interval.
            </summary>
            <param name="first">The first TimeInterval&lt;T&gt; value to compare.</param>
            <param name="second">The second TimeInterval&lt;T&gt; value to compare.</param>
            <returns>true if the first TimeInterval&lt;T&gt; value has the same Value and Interval as the second TimeInterval&lt;T&gt; value; otherwise, false.</returns>
        </member>
        <member name="M:UniRx.TimeInterval`1.op_Inequality(UniRx.TimeInterval{`0},UniRx.TimeInterval{`0})">
            <summary>
            Determines whether the two specified TimeInterval&lt;T&gt; values don't have the same Value and Interval.
            </summary>
            <param name="first">The first TimeInterval&lt;T&gt; value to compare.</param>
            <param name="second">The second TimeInterval&lt;T&gt; value to compare.</param>
            <returns>true if the first TimeInterval&lt;T&gt; value has a different Value or Interval as the second TimeInterval&lt;T&gt; value; otherwise, false.</returns>
        </member>
        <member name="M:UniRx.TimeInterval`1.Equals(System.Object)">
            <summary>
            Determines whether the specified System.Object is equal to the current TimeInterval&lt;T&gt;.
            </summary>
            <param name="obj">The System.Object to compare with the current TimeInterval&lt;T&gt;.</param>
            <returns>true if the specified System.Object is equal to the current TimeInterval&lt;T&gt;; otherwise, false.</returns>
        </member>
        <member name="M:UniRx.TimeInterval`1.GetHashCode">
            <summary>
            Returns the hash code for the current TimeInterval&lt;T&gt; value.
            </summary>
            <returns>A hash code for the current TimeInterval&lt;T&gt; value.</returns>
        </member>
        <member name="M:UniRx.TimeInterval`1.ToString">
            <summary>
            Returns a string representation of the current TimeInterval&lt;T&gt; value.
            </summary>
            <returns>String representation of the current TimeInterval&lt;T&gt; value.</returns>
        </member>
        <member name="T:UniRx.Timestamped`1">
            <summary>
            Represents value with a timestamp on it.
            The timestamp typically represents the time the value was received, using an IScheduler's clock to obtain the current time.
            </summary>
            <typeparam name="T">The type of the value being timestamped.</typeparam>
        </member>
        <member name="M:UniRx.Timestamped`1.#ctor(`0,System.DateTimeOffset)">
            <summary>
            Constructs a timestamped value.
            </summary>
            <param name="value">The value to be annotated with a timestamp.</param>
            <param name="timestamp">Timestamp associated with the value.</param>
        </member>
        <member name="P:UniRx.Timestamped`1.Value">
            <summary>
            Gets the value.
            </summary>
        </member>
        <member name="P:UniRx.Timestamped`1.Timestamp">
            <summary>
            Gets the timestamp.
            </summary>
        </member>
        <member name="M:UniRx.Timestamped`1.Equals(UniRx.Timestamped{`0})">
            <summary>
            Determines whether the current Timestamped&lt;T&gt; value has the same Value and Timestamp as a specified Timestamped&lt;T&gt; value.
            </summary>
            <param name="other">An object to compare to the current Timestamped&lt;T&gt; value.</param>
            <returns>true if both Timestamped&lt;T&gt; values have the same Value and Timestamp; otherwise, false.</returns>
        </member>
        <member name="M:UniRx.Timestamped`1.op_Equality(UniRx.Timestamped{`0},UniRx.Timestamped{`0})">
            <summary>
            Determines whether the two specified Timestamped&lt;T&gt; values have the same Value and Timestamp.
            </summary>
            <param name="first">The first Timestamped&lt;T&gt; value to compare.</param>
            <param name="second">The second Timestamped&lt;T&gt; value to compare.</param>
            <returns>true if the first Timestamped&lt;T&gt; value has the same Value and Timestamp as the second Timestamped&lt;T&gt; value; otherwise, false.</returns>
        </member>
        <member name="M:UniRx.Timestamped`1.op_Inequality(UniRx.Timestamped{`0},UniRx.Timestamped{`0})">
            <summary>
            Determines whether the two specified Timestamped&lt;T&gt; values don't have the same Value and Timestamp.
            </summary>
            <param name="first">The first Timestamped&lt;T&gt; value to compare.</param>
            <param name="second">The second Timestamped&lt;T&gt; value to compare.</param>
            <returns>true if the first Timestamped&lt;T&gt; value has a different Value or Timestamp as the second Timestamped&lt;T&gt; value; otherwise, false.</returns>
        </member>
        <member name="M:UniRx.Timestamped`1.Equals(System.Object)">
            <summary>
            Determines whether the specified System.Object is equal to the current Timestamped&lt;T&gt;.
            </summary>
            <param name="obj">The System.Object to compare with the current Timestamped&lt;T&gt;.</param>
            <returns>true if the specified System.Object is equal to the current Timestamped&lt;T&gt;; otherwise, false.</returns>
        </member>
        <member name="M:UniRx.Timestamped`1.GetHashCode">
            <summary>
            Returns the hash code for the current Timestamped&lt;T&gt; value.
            </summary>
            <returns>A hash code for the current Timestamped&lt;T&gt; value.</returns>
        </member>
        <member name="M:UniRx.Timestamped`1.ToString">
            <summary>
            Returns a string representation of the current Timestamped&lt;T&gt; value.
            </summary>
            <returns>String representation of the current Timestamped&lt;T&gt; value.</returns>
        </member>
        <member name="T:UniRx.Timestamped">
            <summary>
            A helper class with a factory method for creating Timestamped&lt;T&gt; instances.
            </summary>
        </member>
        <member name="M:UniRx.Timestamped.Create``1(``0,System.DateTimeOffset)">
            <summary>
            Creates an instance of a Timestamped&lt;T&gt;.  This is syntactic sugar that uses type inference
            to avoid specifying a type in a constructor call, which is very useful when using anonymous types.
            </summary>
            <param name="value">The value to be annotated with a timestamp.</param>
            <param name="timestamp">Timestamp associated with the value.</param>
            <returns>Creates a new timestamped value.</returns>
        </member>
        <member name="M:UniRx.AsyncOperationExtensions.AsObservable(UnityEngine.AsyncOperation,UniRx.IProgress{System.Single})">
            <summary>
            If you needs return value, use AsAsyncOperationObservable instead.
            </summary>
        </member>
        <member name="F:UniRx.CancellationToken.None">
            <summary>Same as Empty.</summary>
        </member>
        <member name="P:UniRx.Diagnostics.LogEntry.Context">
            <summary>[Optional]</summary>
        </member>
        <member name="P:UniRx.Diagnostics.LogEntry.Exception">
            <summary>[Optional]</summary>
        </member>
        <member name="P:UniRx.Diagnostics.LogEntry.StackTrace">
            <summary>[Optional]</summary>
        </member>
        <member name="P:UniRx.Diagnostics.LogEntry.State">
            <summary>[Optional]</summary>
        </member>
        <member name="M:UniRx.Diagnostics.Logger.Debug(System.Object,UnityEngine.Object)">
            <summary>Output LogType.Log but only enables isDebugBuild</summary>
        </member>
        <member name="M:UniRx.Diagnostics.Logger.DebugFormat(System.String,System.Object[])">
            <summary>Output LogType.Log but only enables isDebugBuild</summary>
        </member>
        <member name="M:UniRx.Diagnostics.Logger.Raw(UniRx.Diagnostics.LogEntry)">
            <summary>Publish raw LogEntry.</summary>
        </member>
        <member name="M:UniRx.Diagnostics.ObservableDebugExtensions.Debug``1(UniRx.IObservable{``0},System.String)">
            <summary>
            Debug helper of observbale stream. Works for only DEBUG symbol.
            </summary>
        </member>
        <member name="M:UniRx.Diagnostics.ObservableDebugExtensions.Debug``1(UniRx.IObservable{``0},UniRx.Diagnostics.Logger)">
            <summary>
            Debug helper of observbale stream. Works for only DEBUG symbol.
            </summary>
        </member>
        <member name="T:UniRx.FrameInterval`1">
            <summary>
            Represents a value associated with time interval information.
            The time interval can represent the time it took to produce the value, the interval relative to a previous value, the value's delivery time relative to a base, etc.
            </summary>
            <typeparam name="T">The type of the value being annotated with time interval information.</typeparam>
        </member>
        <member name="M:UniRx.FrameInterval`1.#ctor(`0,System.Int32)">
            <summary>
            Constructs a time interval value.
            </summary>
            <param name="value">The value to be annotated with a time interval.</param>
            <param name="interval">Time interval associated with the value.</param>
        </member>
        <member name="P:UniRx.FrameInterval`1.Value">
            <summary>
            Gets the value.
            </summary>
        </member>
        <member name="P:UniRx.FrameInterval`1.Interval">
            <summary>
            Gets the interval.
            </summary>
        </member>
        <member name="M:UniRx.FrameInterval`1.Equals(UniRx.FrameInterval{`0})">
            <summary>
            Determines whether the current FrameInterval&lt;T&gt; value has the same Value and Interval as a specified FrameInterval&lt;T&gt; value.
            </summary>
            <param name="other">An object to compare to the current FrameInterval&lt;T&gt; value.</param>
            <returns>true if both FrameInterval&lt;T&gt; values have the same Value and Interval; otherwise, false.</returns>
        </member>
        <member name="M:UniRx.FrameInterval`1.op_Equality(UniRx.FrameInterval{`0},UniRx.FrameInterval{`0})">
            <summary>
            Determines whether the two specified FrameInterval&lt;T&gt; values have the same Value and Interval.
            </summary>
            <param name="first">The first FrameInterval&lt;T&gt; value to compare.</param>
            <param name="second">The second FrameInterval&lt;T&gt; value to compare.</param>
            <returns>true if the first FrameInterval&lt;T&gt; value has the same Value and Interval as the second FrameInterval&lt;T&gt; value; otherwise, false.</returns>
        </member>
        <member name="M:UniRx.FrameInterval`1.op_Inequality(UniRx.FrameInterval{`0},UniRx.FrameInterval{`0})">
            <summary>
            Determines whether the two specified FrameInterval&lt;T&gt; values don't have the same Value and Interval.
            </summary>
            <param name="first">The first FrameInterval&lt;T&gt; value to compare.</param>
            <param name="second">The second FrameInterval&lt;T&gt; value to compare.</param>
            <returns>true if the first FrameInterval&lt;T&gt; value has a different Value or Interval as the second FrameInterval&lt;T&gt; value; otherwise, false.</returns>
        </member>
        <member name="M:UniRx.FrameInterval`1.Equals(System.Object)">
            <summary>
            Determines whether the specified System.Object is equal to the current FrameInterval&lt;T&gt;.
            </summary>
            <param name="obj">The System.Object to compare with the current FrameInterval&lt;T&gt;.</param>
            <returns>true if the specified System.Object is equal to the current FrameInterval&lt;T&gt;; otherwise, false.</returns>
        </member>
        <member name="M:UniRx.FrameInterval`1.GetHashCode">
            <summary>
            Returns the hash code for the current FrameInterval&lt;T&gt; value.
            </summary>
            <returns>A hash code for the current FrameInterval&lt;T&gt; value.</returns>
        </member>
        <member name="M:UniRx.FrameInterval`1.ToString">
            <summary>
            Returns a string representation of the current FrameInterval&lt;T&gt; value.
            </summary>
            <returns>String representation of the current FrameInterval&lt;T&gt; value.</returns>
        </member>
        <member name="T:UniRx.IntReactiveProperty">
            <summary>
            Inspectable ReactiveProperty.
            </summary>
        </member>
        <member name="T:UniRx.LongReactiveProperty">
            <summary>
            Inspectable ReactiveProperty.
            </summary>
        </member>
        <member name="T:UniRx.ByteReactiveProperty">
            <summary>
            Inspectable ReactiveProperty.
            </summary>
        </member>
        <member name="T:UniRx.FloatReactiveProperty">
            <summary>
            Inspectable ReactiveProperty.
            </summary>
        </member>
        <member name="T:UniRx.DoubleReactiveProperty">
            <summary>
            Inspectable ReactiveProperty.
            </summary>
        </member>
        <member name="T:UniRx.StringReactiveProperty">
            <summary>
            Inspectable ReactiveProperty.
            </summary>
        </member>
        <member name="T:UniRx.BoolReactiveProperty">
            <summary>
            Inspectable ReactiveProperty.
            </summary>
        </member>
        <member name="T:UniRx.Vector2ReactiveProperty">
            <summary>Inspectable ReactiveProperty.</summary>
        </member>
        <member name="T:UniRx.Vector3ReactiveProperty">
            <summary>Inspectable ReactiveProperty.</summary>
        </member>
        <member name="T:UniRx.Vector4ReactiveProperty">
            <summary>Inspectable ReactiveProperty.</summary>
        </member>
        <member name="T:UniRx.ColorReactiveProperty">
            <summary>Inspectable ReactiveProperty.</summary>
        </member>
        <member name="T:UniRx.RectReactiveProperty">
            <summary>Inspectable ReactiveProperty.</summary>
        </member>
        <member name="T:UniRx.AnimationCurveReactiveProperty">
            <summary>Inspectable ReactiveProperty.</summary>
        </member>
        <member name="T:UniRx.BoundsReactiveProperty">
            <summary>Inspectable ReactiveProperty.</summary>
        </member>
        <member name="T:UniRx.QuaternionReactiveProperty">
            <summary>Inspectable ReactiveProperty.</summary>
        </member>
        <member name="T:UniRx.MultilineReactivePropertyAttribute">
            <summary>
            Enables multiline input field for StringReactiveProperty. Default line is 3.
            </summary>
        </member>
        <member name="T:UniRx.RangeReactivePropertyAttribute">
            <summary>
            Enables range input field for Int/FloatReactiveProperty.
            </summary>
        </member>
        <member name="P:UniRx.LazyTask`1.Exception">
            <summary>
            If faulted stock error. If completed or canceld, returns null.
            </summary>
        </member>
        <member name="F:UniRx.MainThreadDispatcher.CullingMode.Disabled">
            <summary>
            Won't remove any MainThreadDispatchers.
            </summary>
        </member>
        <member name="F:UniRx.MainThreadDispatcher.CullingMode.Self">
            <summary>
            Checks if there is an existing MainThreadDispatcher on Awake(). If so, the new dispatcher removes itself.
            </summary>
        </member>
        <member name="F:UniRx.MainThreadDispatcher.CullingMode.All">
            <summary>
            Search for excess MainThreadDispatchers and removes them all on Awake().
            </summary>
        </member>
        <member name="M:UniRx.MainThreadDispatcher.Post(System.Action{System.Object},System.Object)">
            <summary>Dispatch Asyncrhonous action.</summary>
        </member>
        <member name="M:UniRx.MainThreadDispatcher.Send(System.Action{System.Object},System.Object)">
            <summary>Dispatch Synchronous action if possible.</summary>
        </member>
        <member name="M:UniRx.MainThreadDispatcher.UnsafeSend(System.Action)">
            <summary>Run Synchronous action.</summary>
        </member>
        <member name="M:UniRx.MainThreadDispatcher.UnsafeSend``1(System.Action{``0},``0)">
            <summary>Run Synchronous action.</summary>
        </member>
        <member name="M:UniRx.MainThreadDispatcher.SendStartCoroutine(System.Collections.IEnumerator)">
            <summary>ThreadSafe StartCoroutine.</summary>
        </member>
        <member name="F:UniRx.MainThreadDispatchType.Update">
            <summary>yield return null</summary>
        </member>
        <member name="F:UniRx.MainThreadDispatchType.AfterUpdate">
            <summary>[Obsolete]Same as Update</summary>
        </member>
        <member name="P:UniRx.ObservableYieldInstruction`1.IsDone">
            <summary>
            HasResult || IsCanceled || HasError
            </summary>
        </member>
        <member name="M:UniRx.ObserveExtensions.ObserveEveryValueChanged``2(``0,System.Func{``0,``1},UniRx.FrameCountType,System.Boolean)">
            <summary>
            Publish target property when value is changed. If source is destroyed/destructed, publish OnCompleted.
            </summary>
            <param name="fastDestroyCheck">If true and target is UnityObject, use destroyed check by additional component. It is faster check for lifecycle but needs initial cost.</param>
        </member>
        <member name="M:UniRx.ObserveExtensions.ObserveEveryValueChanged``2(``0,System.Func{``0,``1},UniRx.FrameCountType,System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Publish target property when value is changed. If source is destroyed/destructed, publish OnCompleted.
            </summary>
        </member>
        <member name="M:UniRx.ObserveExtensions.ObserveEveryValueChanged``2(``0,System.Func{``0,``1},UniRx.FrameCountType,System.Collections.Generic.IEqualityComparer{``1},System.Boolean)">
            <summary>
            Publish target property when value is changed. If source is destroyed/destructed, publish OnCompleted.
            </summary>
            <param name="fastDestroyCheck">If true and target is UnityObject, use destroyed check by additional component. It is faster check for lifecycle but needs initial cost.</param>
        </member>
        <member name="T:UniRx.IPresenter">
            <summary>
            [Obsolete]Infrastructure interface for PresenterBase`T
            </summary>
        </member>
        <member name="T:UniRx.PresenterBase">
            <summary>
            [Obsolete]PresenterBase can control dependency of presenter's hierarchy.
            </summary>
        </member>
        <member name="M:UniRx.PresenterBase.BeforeInitialize">
            <summary>
            Same as Start but called before children initialized, it's chance for propagate argument to children.
            </summary>
        </member>
        <member name="M:UniRx.PresenterBase.ForceInitialize">
            <summary>
            Force Start BeforeInitialize/Initialize. If you create presenter dynamically, maybe useful.
            </summary>
        </member>
        <member name="M:UniRx.PresenterBase.Initialize">
            <summary>
            Same as Start but called after all children are initialized.
            </summary>
        </member>
        <member name="T:UniRx.PresenterBase`1">
            <summary>
            [Obsolete]PresenterBase can control dependency of presenter's hierarchy.
            </summary>
        </member>
        <member name="M:UniRx.PresenterBase`1.InitializeAsObservable">
            <summary>
            Observable sequence called after initialize completed.
            </summary>
        </member>
        <member name="M:UniRx.PresenterBase`1.PropagateArgument(`0)">
            <summary>
            Propagate(Set) argument.
            </summary>
        </member>
        <member name="P:UniRx.PresenterBase`1.Children">
            <summary>
            Dependency on hierarchy of this presenter. If Children is empty, you can return this.EmptyChildren.
            </summary>
        </member>
        <member name="M:UniRx.PresenterBase`1.BeforeInitialize(`0)">
            <summary>
            Same as Start but called before children initialized, it's chance for propagate argument to children.
            </summary>
        </member>
        <member name="M:UniRx.PresenterBase`1.Initialize(`0)">
            <summary>
            Same as Start but called after all children are initialized.
            </summary>
        </member>
        <member name="M:UniRx.PresenterBase`1.ForceInitialize(`0)">
            <summary>
            Force Start BeforeInitialize/Initialize. If you create presenter dynamically, maybe useful.
            </summary>
        </member>
        <member name="M:UniRx.PresenterBase`1.Awake">
            <summary>Infrastructure method called by UnityEngine. If you needs override Awake, override OnAwake.</summary>
        </member>
        <member name="M:UniRx.PresenterBase`1.OnAwake">
            <summary>An alternative of Awake.</summary>
        </member>
        <member name="M:UniRx.PresenterBase`1.Start">
            <summary>Infrastructure method called by UnityEngine. don't call directly, don't override, don't hide!</summary>
        </member>
        <member name="T:UniRx.ReactiveCommand">
            <summary>
            Represents ReactiveCommand&lt;Unit&gt;
            </summary>
        </member>
        <member name="M:UniRx.ReactiveCommand.#ctor">
            <summary>
            CanExecute is always true.
            </summary>
        </member>
        <member name="M:UniRx.ReactiveCommand.#ctor(UniRx.IObservable{System.Boolean},System.Boolean)">
            <summary>
            CanExecute is changed from canExecute sequence.
            </summary>
        </member>
        <member name="M:UniRx.ReactiveCommand.Execute">
            <summary>Push null to subscribers.</summary>
        </member>
        <member name="M:UniRx.ReactiveCommand.ForceExecute">
            <summary>Force push parameter to subscribers.</summary>
        </member>
        <member name="M:UniRx.ReactiveCommand`1.#ctor">
            <summary>
            CanExecute is always true.
            </summary>
        </member>
        <member name="M:UniRx.ReactiveCommand`1.#ctor(UniRx.IObservable{System.Boolean},System.Boolean)">
            <summary>
            CanExecute is changed from canExecute sequence.
            </summary>
        </member>
        <member name="M:UniRx.ReactiveCommand`1.Execute(`0)">
            <summary>Push parameter to subscribers when CanExecute.</summary>
        </member>
        <member name="M:UniRx.ReactiveCommand`1.ForceExecute(`0)">
            <summary>Force push parameter to subscribers.</summary>
        </member>
        <member name="M:UniRx.ReactiveCommand`1.Subscribe(UniRx.IObserver{`0})">
            <summary>Subscribe execute.</summary>
        </member>
        <member name="M:UniRx.ReactiveCommand`1.Dispose">
            <summary>
            Stop all subscription and lock CanExecute is false.
            </summary>
        </member>
        <member name="T:UniRx.AsyncReactiveCommand">
            <summary>
            Variation of ReactiveCommand, when executing command then CanExecute = false after CanExecute = true.
            </summary>
        </member>
        <member name="M:UniRx.AsyncReactiveCommand.#ctor">
            <summary>
            CanExecute is automatically changed when executing to false and finished to true.
            </summary>
        </member>
        <member name="M:UniRx.AsyncReactiveCommand.#ctor(UniRx.IObservable{System.Boolean})">
            <summary>
            CanExecute is automatically changed when executing to false and finished to true.
            </summary>
        </member>
        <member name="M:UniRx.AsyncReactiveCommand.#ctor(UniRx.IReactiveProperty{System.Boolean})">
            <summary>
            CanExecute is automatically changed when executing to false and finished to true.
            The source is shared between other AsyncReactiveCommand.
            </summary>
        </member>
        <member name="T:UniRx.AsyncReactiveCommand`1">
            <summary>
            Variation of ReactiveCommand, canExecute is changed when executing command then CanExecute = false after CanExecute = true.
            </summary>
        </member>
        <member name="M:UniRx.AsyncReactiveCommand`1.#ctor">
            <summary>
            CanExecute is automatically changed when executing to false and finished to true.
            </summary>
        </member>
        <member name="M:UniRx.AsyncReactiveCommand`1.#ctor(UniRx.IObservable{System.Boolean})">
            <summary>
            CanExecute is automatically changed when executing to false and finished to true.
            </summary>
        </member>
        <member name="M:UniRx.AsyncReactiveCommand`1.#ctor(UniRx.IReactiveProperty{System.Boolean})">
            <summary>
            CanExecute is automatically changed when executing to false and finished to true.
            The source is shared between other AsyncReactiveCommand.
            </summary>
        </member>
        <member name="M:UniRx.AsyncReactiveCommand`1.Execute(`0)">
            <summary>Push parameter to subscribers when CanExecute.</summary>
        </member>
        <member name="M:UniRx.AsyncReactiveCommand`1.Subscribe(System.Func{`0,UniRx.IObservable{UniRx.Unit}})">
            <summary>Subscribe execute.</summary>
        </member>
        <member name="M:UniRx.ReactiveCommandExtensions.ToReactiveCommand(UniRx.IObservable{System.Boolean},System.Boolean)">
            <summary>
            Create non parameter commands. CanExecute is changed from canExecute sequence.
            </summary>
        </member>
        <member name="M:UniRx.ReactiveCommandExtensions.ToReactiveCommand``1(UniRx.IObservable{System.Boolean},System.Boolean)">
            <summary>
            Create parametered comamnds. CanExecute is changed from canExecute sequence.
            </summary>
        </member>
        <member name="M:UniRx.ReactiveCommandExtensions.BindTo(UniRx.ReactiveCommand{UniRx.Unit},UnityEngine.UI.Button)">
            <summary>
            Bind RaectiveCommand to button's interactable and onClick.
            </summary>
        </member>
        <member name="M:UniRx.ReactiveCommandExtensions.BindToOnClick(UniRx.ReactiveCommand{UniRx.Unit},UnityEngine.UI.Button,System.Action{UniRx.Unit})">
            <summary>
            Bind RaectiveCommand to button's interactable and onClick and register onClick action to command.
            </summary>
        </member>
        <member name="M:UniRx.ReactiveCommandExtensions.BindToButtonOnClick(UniRx.IObservable{System.Boolean},UnityEngine.UI.Button,System.Action{UniRx.Unit},System.Boolean)">
            <summary>
            Bind canExecuteSource to button's interactable and onClick and register onClick action to command.
            </summary>
        </member>
        <member name="M:UniRx.AsyncReactiveCommandExtensions.BindTo(UniRx.AsyncReactiveCommand{UniRx.Unit},UnityEngine.UI.Button)">
            <summary>
            Bind AsyncRaectiveCommand to button's interactable and onClick.
            </summary>
        </member>
        <member name="M:UniRx.AsyncReactiveCommandExtensions.BindToOnClick(UniRx.AsyncReactiveCommand{UniRx.Unit},UnityEngine.UI.Button,System.Func{UniRx.Unit,UniRx.IObservable{UniRx.Unit}})">
            <summary>
            Bind AsyncRaectiveCommand to button's interactable and onClick and register async action to command.
            </summary>
        </member>
        <member name="M:UniRx.AsyncReactiveCommandExtensions.BindToOnClick(UnityEngine.UI.Button,System.Func{UniRx.Unit,UniRx.IObservable{UniRx.Unit}})">
            <summary>
            Create AsyncReactiveCommand and bind to button's interactable and onClick and register async action to command.
            </summary>
        </member>
        <member name="M:UniRx.AsyncReactiveCommandExtensions.BindToOnClick(UnityEngine.UI.Button,UniRx.IReactiveProperty{System.Boolean},System.Func{UniRx.Unit,UniRx.IObservable{UniRx.Unit}})">
            <summary>
            Create AsyncReactiveCommand and bind sharedCanExecuteSource source to button's interactable and onClick and register async action to command.
            </summary>
        </member>
        <member name="T:UniRx.ReactiveProperty`1">
            <summary>
            Lightweight property broker.
            </summary>
        </member>
        <member name="T:UniRx.ReadOnlyReactiveProperty`1">
            <summary>
            Lightweight property broker.
            </summary>
        </member>
        <member name="T:UniRx.ReactivePropertyExtensions">
            <summary>
            Extension methods of ReactiveProperty&lt;T&gt;
            </summary>
        </member>
        <member name="M:UniRx.ReactivePropertyExtensions.ToSequentialReadOnlyReactiveProperty``1(UniRx.IObservable{``0})">
            <summary>
            Create ReadOnlyReactiveProperty with distinctUntilChanged: false.
            </summary>
        </member>
        <member name="M:UniRx.ReactivePropertyExtensions.ToSequentialReadOnlyReactiveProperty``1(UniRx.IObservable{``0},``0)">
            <summary>
            Create ReadOnlyReactiveProperty with distinctUntilChanged: false.
            </summary>
        </member>
        <member name="M:UniRx.ReactivePropertyExtensions.CombineLatestValuesAreAllTrue(System.Collections.Generic.IEnumerable{UniRx.IObservable{System.Boolean}})">
            <summary>
            Lastest values of each sequence are all true.
            </summary>
        </member>
        <member name="M:UniRx.ReactivePropertyExtensions.CombineLatestValuesAreAllFalse(System.Collections.Generic.IEnumerable{UniRx.IObservable{System.Boolean}})">
            <summary>
            Lastest values of each sequence are all false.
            </summary>
        </member>
        <member name="T:UniRx.Toolkit.ObjectPool`1">
            <summary>
            Bass class of ObjectPool.
            </summary>
        </member>
        <member name="P:UniRx.Toolkit.ObjectPool`1.MaxPoolCount">
            <summary>
            Limit of instace count.
            </summary>
        </member>
        <member name="M:UniRx.Toolkit.ObjectPool`1.CreateInstance">
            <summary>
            Create instance when needed.
            </summary>
        </member>
        <member name="M:UniRx.Toolkit.ObjectPool`1.OnBeforeRent(`0)">
            <summary>
            Called before return to pool, useful for set active object(it is default behavior).
            </summary>
        </member>
        <member name="M:UniRx.Toolkit.ObjectPool`1.OnBeforeReturn(`0)">
            <summary>
            Called before return to pool, useful for set inactive object(it is default behavior).
            </summary>
        </member>
        <member name="M:UniRx.Toolkit.ObjectPool`1.OnClear(`0)">
            <summary>
            Called when clear or disposed, useful for destroy instance or other finalize method.
            </summary>
        </member>
        <member name="P:UniRx.Toolkit.ObjectPool`1.Count">
            <summary>
            Current pooled object count.
            </summary>
        </member>
        <member name="M:UniRx.Toolkit.ObjectPool`1.Rent">
            <summary>
            Get instance from pool.
            </summary>
        </member>
        <member name="M:UniRx.Toolkit.ObjectPool`1.Return(`0)">
            <summary>
            Return instance to pool.
            </summary>
        </member>
        <member name="M:UniRx.Toolkit.ObjectPool`1.Clear(System.Boolean)">
            <summary>
            Clear pool.
            </summary>
        </member>
        <member name="M:UniRx.Toolkit.ObjectPool`1.Shrink(System.Single,System.Int32,System.Boolean)">
            <summary>
            Trim pool instances. 
            </summary>
            <param name="instanceCountRatio">0.0f = clear all ~ 1.0f = live all.</param>
            <param name="minSize">Min pool count.</param>
            <param name="callOnBeforeRent">If true, call OnBeforeRent before OnClear.</param>
        </member>
        <member name="M:UniRx.Toolkit.ObjectPool`1.StartShrinkTimer(System.TimeSpan,System.Single,System.Int32,System.Boolean)">
            <summary>
            If needs shrink pool frequently, start check timer.
            </summary>
            <param name="checkInterval">Interval of call Shrink.</param>
            <param name="instanceCountRatio">0.0f = clearAll ~ 1.0f = live all.</param>
            <param name="minSize">Min pool count.</param>
            <param name="callOnBeforeRent">If true, call OnBeforeRent before OnClear.</param>
        </member>
        <member name="M:UniRx.Toolkit.ObjectPool`1.PreloadAsync(System.Int32,System.Int32)">
            <summary>
            Fill pool before rent operation.
            </summary>
            <param name="preloadCount">Pool instance count.</param>
            <param name="threshold">Create count per frame.</param>
        </member>
        <member name="T:UniRx.Toolkit.AsyncObjectPool`1">
            <summary>
            Bass class of ObjectPool. If needs asynchronous initialization, use this instead of standard ObjectPool.
            </summary>
        </member>
        <member name="P:UniRx.Toolkit.AsyncObjectPool`1.MaxPoolCount">
            <summary>
            Limit of instace count.
            </summary>
        </member>
        <member name="M:UniRx.Toolkit.AsyncObjectPool`1.CreateInstanceAsync">
            <summary>
            Create instance when needed.
            </summary>
        </member>
        <member name="M:UniRx.Toolkit.AsyncObjectPool`1.OnBeforeRent(`0)">
            <summary>
            Called before return to pool, useful for set active object(it is default behavior).
            </summary>
        </member>
        <member name="M:UniRx.Toolkit.AsyncObjectPool`1.OnBeforeReturn(`0)">
            <summary>
            Called before return to pool, useful for set inactive object(it is default behavior).
            </summary>
        </member>
        <member name="M:UniRx.Toolkit.AsyncObjectPool`1.OnClear(`0)">
            <summary>
            Called when clear or disposed, useful for destroy instance or other finalize method.
            </summary>
        </member>
        <member name="P:UniRx.Toolkit.AsyncObjectPool`1.Count">
            <summary>
            Current pooled object count.
            </summary>
        </member>
        <member name="M:UniRx.Toolkit.AsyncObjectPool`1.RentAsync">
            <summary>
            Get instance from pool.
            </summary>
        </member>
        <member name="M:UniRx.Toolkit.AsyncObjectPool`1.Return(`0)">
            <summary>
            Return instance to pool.
            </summary>
        </member>
        <member name="M:UniRx.Toolkit.AsyncObjectPool`1.Shrink(System.Single,System.Int32,System.Boolean)">
            <summary>
            Trim pool instances. 
            </summary>
            <param name="instanceCountRatio">0.0f = clear all ~ 1.0f = live all.</param>
            <param name="minSize">Min pool count.</param>
            <param name="callOnBeforeRent">If true, call OnBeforeRent before OnClear.</param>
        </member>
        <member name="M:UniRx.Toolkit.AsyncObjectPool`1.StartShrinkTimer(System.TimeSpan,System.Single,System.Int32,System.Boolean)">
            <summary>
            If needs shrink pool frequently, start check timer.
            </summary>
            <param name="checkInterval">Interval of call Shrink.</param>
            <param name="instanceCountRatio">0.0f = clearAll ~ 1.0f = live all.</param>
            <param name="minSize">Min pool count.</param>
            <param name="callOnBeforeRent">If true, call OnBeforeRent before OnClear.</param>
        </member>
        <member name="M:UniRx.Toolkit.AsyncObjectPool`1.Clear(System.Boolean)">
            <summary>
            Clear pool.
            </summary>
        </member>
        <member name="M:UniRx.Toolkit.AsyncObjectPool`1.PreloadAsync(System.Int32,System.Int32)">
            <summary>
            Fill pool before rent operation.
            </summary>
            <param name="preloadCount">Pool instance count.</param>
            <param name="threshold">Create count per frame.</param>
        </member>
        <member name="M:UniRx.Triggers.ObservableAnimatorTrigger.OnAnimatorIK(System.Int32)">
            <summary>Callback for setting up animation IK (inverse kinematics).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableAnimatorTrigger.OnAnimatorIKAsObservable">
            <summary>Callback for setting up animation IK (inverse kinematics).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableAnimatorTrigger.OnAnimatorMove">
            <summary>Callback for processing animation movements for modifying root motion.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableAnimatorTrigger.OnAnimatorMoveAsObservable">
            <summary>Callback for processing animation movements for modifying root motion.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableCanvasGroupChangedTrigger.OnCanvasGroupChangedAsObservable">
            <summary>Callback that is sent if the canvas group is changed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableCollision2DTrigger.OnCollisionEnter2D(UnityEngine.Collision2D)">
            <summary>Sent when an incoming collider makes contact with this object's collider (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableCollision2DTrigger.OnCollisionEnter2DAsObservable">
            <summary>Sent when an incoming collider makes contact with this object's collider (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableCollision2DTrigger.OnCollisionExit2D(UnityEngine.Collision2D)">
            <summary>Sent when a collider on another object stops touching this object's collider (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableCollision2DTrigger.OnCollisionExit2DAsObservable">
            <summary>Sent when a collider on another object stops touching this object's collider (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableCollision2DTrigger.OnCollisionStay2D(UnityEngine.Collision2D)">
            <summary>Sent each frame where a collider on another object is touching this object's collider (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableCollision2DTrigger.OnCollisionStay2DAsObservable">
            <summary>Sent each frame where a collider on another object is touching this object's collider (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableCollisionTrigger.OnCollisionEnter(UnityEngine.Collision)">
            <summary>OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableCollisionTrigger.OnCollisionEnterAsObservable">
            <summary>OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableCollisionTrigger.OnCollisionExit(UnityEngine.Collision)">
            <summary>OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableCollisionTrigger.OnCollisionExitAsObservable">
            <summary>OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableCollisionTrigger.OnCollisionStay(UnityEngine.Collision)">
            <summary>OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableCollisionTrigger.OnCollisionStayAsObservable">
            <summary>OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider.</summary>
        </member>
        <member name="P:UniRx.Triggers.ObservableDestroyTrigger.IsCalledOnDestroy">
            <summary>
            Check called OnDestroy.
            This property does not guarantees GameObject was destroyed,
            when gameObject is deactive, does not raise OnDestroy.
            </summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableDestroyTrigger.OnDestroy">
            <summary>This function is called when the MonoBehaviour will be destroyed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableDestroyTrigger.OnDestroyAsObservable">
            <summary>This function is called when the MonoBehaviour will be destroyed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableDestroyTrigger.ForceRaiseOnDestroy">
            <summary>Invoke OnDestroy, this method is used on internal.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableEnableTrigger.OnEnable">
            <summary>This function is called when the object becomes enabled and active.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableEnableTrigger.OnEnableAsObservable">
            <summary>This function is called when the object becomes enabled and active.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableEnableTrigger.OnDisable">
            <summary>This function is called when the behaviour becomes disabled () or inactive.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableEnableTrigger.OnDisableAsObservable">
            <summary>This function is called when the behaviour becomes disabled () or inactive.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableFixedUpdateTrigger.FixedUpdate">
            <summary>This function is called every fixed framerate frame, if the MonoBehaviour is enabled.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableFixedUpdateTrigger.FixedUpdateAsObservable">
            <summary>This function is called every fixed framerate frame, if the MonoBehaviour is enabled.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableLateUpdateTrigger.LateUpdate">
            <summary>LateUpdate is called every frame, if the Behaviour is enabled.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableLateUpdateTrigger.LateUpdateAsObservable">
            <summary>LateUpdate is called every frame, if the Behaviour is enabled.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableMouseTrigger.OnMouseDown">
            <summary>OnMouseDown is called when the user has pressed the mouse button while over the GUIElement or Collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableMouseTrigger.OnMouseDownAsObservable">
            <summary>OnMouseDown is called when the user has pressed the mouse button while over the GUIElement or Collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableMouseTrigger.OnMouseDrag">
            <summary>OnMouseDrag is called when the user has clicked on a GUIElement or Collider and is still holding down the mouse.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableMouseTrigger.OnMouseDragAsObservable">
            <summary>OnMouseDrag is called when the user has clicked on a GUIElement or Collider and is still holding down the mouse.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableMouseTrigger.OnMouseEnter">
            <summary>OnMouseEnter is called when the mouse entered the GUIElement or Collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableMouseTrigger.OnMouseEnterAsObservable">
            <summary>OnMouseEnter is called when the mouse entered the GUIElement or Collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableMouseTrigger.OnMouseExit">
            <summary>OnMouseExit is called when the mouse is not any longer over the GUIElement or Collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableMouseTrigger.OnMouseExitAsObservable">
            <summary>OnMouseExit is called when the mouse is not any longer over the GUIElement or Collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableMouseTrigger.OnMouseOver">
            <summary>OnMouseOver is called every frame while the mouse is over the GUIElement or Collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableMouseTrigger.OnMouseOverAsObservable">
            <summary>OnMouseOver is called every frame while the mouse is over the GUIElement or Collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableMouseTrigger.OnMouseUp">
            <summary>OnMouseUp is called when the user has released the mouse button.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableMouseTrigger.OnMouseUpAsObservable">
            <summary>OnMouseUp is called when the user has released the mouse button.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableMouseTrigger.OnMouseUpAsButton">
            <summary>OnMouseUpAsButton is only called when the mouse is released over the same GUIElement or Collider as it was pressed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableMouseTrigger.OnMouseUpAsButtonAsObservable">
            <summary>OnMouseUpAsButton is only called when the mouse is released over the same GUIElement or Collider as it was pressed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableParticleTrigger.OnParticleCollision(UnityEngine.GameObject)">
            <summary>OnParticleCollision is called when a particle hits a collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableParticleTrigger.OnParticleCollisionAsObservable">
            <summary>OnParticleCollision is called when a particle hits a collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableParticleTrigger.OnParticleTrigger">
            <summary>OnParticleTrigger is called when any particles in a particle system meet the conditions in the trigger module.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableParticleTrigger.OnParticleTriggerAsObservable">
            <summary>OnParticleTrigger is called when any particles in a particle system meet the conditions in the trigger module.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableRectTransformTrigger.OnRectTransformDimensionsChangeAsObservable">
            <summary>Callback that is sent if an associated RectTransform has it's dimensions changed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableRectTransformTrigger.OnRectTransformRemovedAsObservable">
            <summary>Callback that is sent if an associated RectTransform is removed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTransformChangedTrigger.OnBeforeTransformParentChangedAsObservable">
            <summary>Callback sent to the graphic before a Transform parent change occurs.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTransformChangedTrigger.OnTransformParentChangedAsObservable">
            <summary>This function is called when the parent property of the transform of the GameObject has changed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTransformChangedTrigger.OnTransformChildrenChangedAsObservable">
            <summary>This function is called when the list of children of the transform of the GameObject has changed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTrigger2DTrigger.OnTriggerEnter2D(UnityEngine.Collider2D)">
            <summary>Sent when another object enters a trigger collider attached to this object (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTrigger2DTrigger.OnTriggerEnter2DAsObservable">
            <summary>Sent when another object enters a trigger collider attached to this object (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTrigger2DTrigger.OnTriggerExit2D(UnityEngine.Collider2D)">
            <summary>Sent when another object leaves a trigger collider attached to this object (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTrigger2DTrigger.OnTriggerExit2DAsObservable">
            <summary>Sent when another object leaves a trigger collider attached to this object (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTrigger2DTrigger.OnTriggerStay2D(UnityEngine.Collider2D)">
            <summary>Sent each frame where another object is within a trigger collider attached to this object (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTrigger2DTrigger.OnTriggerStay2DAsObservable">
            <summary>Sent each frame where another object is within a trigger collider attached to this object (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerBase.Awake">
            <summary>Awake is called when the script instance is being loaded.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerBase.AwakeAsObservable">
            <summary>Awake is called when the script instance is being loaded.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerBase.Start">
            <summary>Start is called on the frame when a script is enabled just before any of the Update methods is called the first time.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerBase.StartAsObservable">
            <summary>Start is called on the frame when a script is enabled just before any of the Update methods is called the first time.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerBase.OnDestroy">
            <summary>This function is called when the MonoBehaviour will be destroyed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerBase.OnDestroyAsObservable">
            <summary>This function is called when the MonoBehaviour will be destroyed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnAnimatorIKAsObservable(UnityEngine.Component)">
            <summary>Callback for setting up animation IK (inverse kinematics).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnAnimatorMoveAsObservable(UnityEngine.Component)">
            <summary>Callback for processing animation movements for modifying root motion.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnCollisionEnter2DAsObservable(UnityEngine.Component)">
            <summary>Sent when an incoming collider makes contact with this object's collider (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnCollisionExit2DAsObservable(UnityEngine.Component)">
            <summary>Sent when a collider on another object stops touching this object's collider (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnCollisionStay2DAsObservable(UnityEngine.Component)">
            <summary>Sent each frame where a collider on another object is touching this object's collider (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnCollisionEnterAsObservable(UnityEngine.Component)">
            <summary>OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnCollisionExitAsObservable(UnityEngine.Component)">
            <summary>OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnCollisionStayAsObservable(UnityEngine.Component)">
            <summary>OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnDestroyAsObservable(UnityEngine.Component)">
            <summary>This function is called when the MonoBehaviour will be destroyed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnEnableAsObservable(UnityEngine.Component)">
            <summary>This function is called when the object becomes enabled and active.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnDisableAsObservable(UnityEngine.Component)">
            <summary>This function is called when the behaviour becomes disabled () or inactive.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.FixedUpdateAsObservable(UnityEngine.Component)">
            <summary>This function is called every fixed framerate frame, if the MonoBehaviour is enabled.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.LateUpdateAsObservable(UnityEngine.Component)">
            <summary>LateUpdate is called every frame, if the Behaviour is enabled.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnMouseDownAsObservable(UnityEngine.Component)">
            <summary>OnMouseDown is called when the user has pressed the mouse button while over the GUIElement or Collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnMouseDragAsObservable(UnityEngine.Component)">
            <summary>OnMouseDrag is called when the user has clicked on a GUIElement or Collider and is still holding down the mouse.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnMouseEnterAsObservable(UnityEngine.Component)">
            <summary>OnMouseEnter is called when the mouse entered the GUIElement or Collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnMouseExitAsObservable(UnityEngine.Component)">
            <summary>OnMouseExit is called when the mouse is not any longer over the GUIElement or Collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnMouseOverAsObservable(UnityEngine.Component)">
            <summary>OnMouseOver is called every frame while the mouse is over the GUIElement or Collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnMouseUpAsObservable(UnityEngine.Component)">
            <summary>OnMouseUp is called when the user has released the mouse button.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnMouseUpAsButtonAsObservable(UnityEngine.Component)">
            <summary>OnMouseUpAsButton is only called when the mouse is released over the same GUIElement or Collider as it was pressed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnTriggerEnter2DAsObservable(UnityEngine.Component)">
            <summary>Sent when another object enters a trigger collider attached to this object (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnTriggerExit2DAsObservable(UnityEngine.Component)">
            <summary>Sent when another object leaves a trigger collider attached to this object (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnTriggerStay2DAsObservable(UnityEngine.Component)">
            <summary>Sent each frame where another object is within a trigger collider attached to this object (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnTriggerEnterAsObservable(UnityEngine.Component)">
            <summary>OnTriggerEnter is called when the Collider other enters the trigger.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnTriggerExitAsObservable(UnityEngine.Component)">
            <summary>OnTriggerExit is called when the Collider other has stopped touching the trigger.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnTriggerStayAsObservable(UnityEngine.Component)">
            <summary>OnTriggerStay is called once per frame for every Collider other that is touching the trigger.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.UpdateAsObservable(UnityEngine.Component)">
            <summary>Update is called every frame, if the MonoBehaviour is enabled.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnBecameInvisibleAsObservable(UnityEngine.Component)">
            <summary>OnBecameInvisible is called when the renderer is no longer visible by any camera.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnBecameVisibleAsObservable(UnityEngine.Component)">
            <summary>OnBecameVisible is called when the renderer became visible by any camera.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnBeforeTransformParentChangedAsObservable(UnityEngine.Component)">
            <summary>Callback sent to the graphic before a Transform parent change occurs.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnTransformParentChangedAsObservable(UnityEngine.Component)">
            <summary>This function is called when the parent property of the transform of the GameObject has changed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnTransformChildrenChangedAsObservable(UnityEngine.Component)">
            <summary>This function is called when the list of children of the transform of the GameObject has changed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnCanvasGroupChangedAsObservable(UnityEngine.Component)">
            <summary>Callback that is sent if the canvas group is changed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnRectTransformDimensionsChangeAsObservable(UnityEngine.Component)">
            <summary>Callback that is sent if an associated RectTransform has it's dimensions changed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnRectTransformRemovedAsObservable(UnityEngine.Component)">
            <summary>Callback that is sent if an associated RectTransform is removed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnParticleCollisionAsObservable(UnityEngine.Component)">
            <summary>OnParticleCollision is called when a particle hits a collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnParticleTriggerAsObservable(UnityEngine.Component)">
            <summary>OnParticleTrigger is called when any particles in a particle system meet the conditions in the trigger module.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnAnimatorIKAsObservable(UnityEngine.GameObject)">
            <summary>Callback for setting up animation IK (inverse kinematics).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnAnimatorMoveAsObservable(UnityEngine.GameObject)">
            <summary>Callback for processing animation movements for modifying root motion.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnCollisionEnter2DAsObservable(UnityEngine.GameObject)">
            <summary>Sent when an incoming collider makes contact with this object's collider (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnCollisionExit2DAsObservable(UnityEngine.GameObject)">
            <summary>Sent when a collider on another object stops touching this object's collider (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnCollisionStay2DAsObservable(UnityEngine.GameObject)">
            <summary>Sent each frame where a collider on another object is touching this object's collider (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnCollisionEnterAsObservable(UnityEngine.GameObject)">
            <summary>OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnCollisionExitAsObservable(UnityEngine.GameObject)">
            <summary>OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnCollisionStayAsObservable(UnityEngine.GameObject)">
            <summary>OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnDestroyAsObservable(UnityEngine.GameObject)">
            <summary>This function is called when the MonoBehaviour will be destroyed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnEnableAsObservable(UnityEngine.GameObject)">
            <summary>This function is called when the object becomes enabled and active.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnDisableAsObservable(UnityEngine.GameObject)">
            <summary>This function is called when the behaviour becomes disabled () or inactive.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.FixedUpdateAsObservable(UnityEngine.GameObject)">
            <summary>This function is called every fixed framerate frame, if the MonoBehaviour is enabled.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.LateUpdateAsObservable(UnityEngine.GameObject)">
            <summary>LateUpdate is called every frame, if the Behaviour is enabled.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnMouseDownAsObservable(UnityEngine.GameObject)">
            <summary>OnMouseDown is called when the user has pressed the mouse button while over the GUIElement or Collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnMouseDragAsObservable(UnityEngine.GameObject)">
            <summary>OnMouseDrag is called when the user has clicked on a GUIElement or Collider and is still holding down the mouse.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnMouseEnterAsObservable(UnityEngine.GameObject)">
            <summary>OnMouseEnter is called when the mouse entered the GUIElement or Collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnMouseExitAsObservable(UnityEngine.GameObject)">
            <summary>OnMouseExit is called when the mouse is not any longer over the GUIElement or Collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnMouseOverAsObservable(UnityEngine.GameObject)">
            <summary>OnMouseOver is called every frame while the mouse is over the GUIElement or Collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnMouseUpAsObservable(UnityEngine.GameObject)">
            <summary>OnMouseUp is called when the user has released the mouse button.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnMouseUpAsButtonAsObservable(UnityEngine.GameObject)">
            <summary>OnMouseUpAsButton is only called when the mouse is released over the same GUIElement or Collider as it was pressed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnTriggerEnter2DAsObservable(UnityEngine.GameObject)">
            <summary>Sent when another object enters a trigger collider attached to this object (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnTriggerExit2DAsObservable(UnityEngine.GameObject)">
            <summary>Sent when another object leaves a trigger collider attached to this object (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnTriggerStay2DAsObservable(UnityEngine.GameObject)">
            <summary>Sent each frame where another object is within a trigger collider attached to this object (2D physics only).</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnTriggerEnterAsObservable(UnityEngine.GameObject)">
            <summary>OnTriggerEnter is called when the Collider other enters the trigger.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnTriggerExitAsObservable(UnityEngine.GameObject)">
            <summary>OnTriggerExit is called when the Collider other has stopped touching the trigger.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnTriggerStayAsObservable(UnityEngine.GameObject)">
            <summary>OnTriggerStay is called once per frame for every Collider other that is touching the trigger.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.UpdateAsObservable(UnityEngine.GameObject)">
            <summary>Update is called every frame, if the MonoBehaviour is enabled.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnBecameInvisibleAsObservable(UnityEngine.GameObject)">
            <summary>OnBecameInvisible is called when the renderer is no longer visible by any camera.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnBecameVisibleAsObservable(UnityEngine.GameObject)">
            <summary>OnBecameVisible is called when the renderer became visible by any camera.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnBeforeTransformParentChangedAsObservable(UnityEngine.GameObject)">
            <summary>Callback sent to the graphic before a Transform parent change occurs.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnTransformParentChangedAsObservable(UnityEngine.GameObject)">
            <summary>This function is called when the parent property of the transform of the GameObject has changed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnTransformChildrenChangedAsObservable(UnityEngine.GameObject)">
            <summary>This function is called when the list of children of the transform of the GameObject has changed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnCanvasGroupChangedAsObservable(UnityEngine.GameObject)">
            <summary>Callback that is sent if the canvas group is changed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnRectTransformDimensionsChangeAsObservable(UnityEngine.GameObject)">
            <summary>Callback that is sent if an associated RectTransform has it's dimensions changed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnRectTransformRemovedAsObservable(UnityEngine.GameObject)">
            <summary>Callback that is sent if an associated RectTransform is removed.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnParticleCollisionAsObservable(UnityEngine.GameObject)">
            <summary>OnParticleCollision is called when a particle hits a collider.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerExtensions.OnParticleTriggerAsObservable(UnityEngine.GameObject)">
            <summary>OnParticleTrigger is called when any particles in a particle system meet the conditions in the trigger module.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerTrigger.OnTriggerEnter(UnityEngine.Collider)">
            <summary>OnTriggerEnter is called when the Collider other enters the trigger.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerTrigger.OnTriggerEnterAsObservable">
            <summary>OnTriggerEnter is called when the Collider other enters the trigger.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerTrigger.OnTriggerExit(UnityEngine.Collider)">
            <summary>OnTriggerExit is called when the Collider other has stopped touching the trigger.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerTrigger.OnTriggerExitAsObservable">
            <summary>OnTriggerExit is called when the Collider other has stopped touching the trigger.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerTrigger.OnTriggerStay(UnityEngine.Collider)">
            <summary>OnTriggerStay is called once per frame for every Collider other that is touching the trigger.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableTriggerTrigger.OnTriggerStayAsObservable">
            <summary>OnTriggerStay is called once per frame for every Collider other that is touching the trigger.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableUpdateTrigger.Update">
            <summary>Update is called every frame, if the MonoBehaviour is enabled.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableUpdateTrigger.UpdateAsObservable">
            <summary>Update is called every frame, if the MonoBehaviour is enabled.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableVisibleTrigger.OnBecameInvisible">
            <summary>OnBecameInvisible is called when the renderer is no longer visible by any camera.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableVisibleTrigger.OnBecameInvisibleAsObservable">
            <summary>OnBecameInvisible is called when the renderer is no longer visible by any camera.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableVisibleTrigger.OnBecameVisible">
            <summary>OnBecameVisible is called when the renderer became visible by any camera.</summary>
        </member>
        <member name="M:UniRx.Triggers.ObservableVisibleTrigger.OnBecameVisibleAsObservable">
            <summary>OnBecameVisible is called when the renderer became visible by any camera.</summary>
        </member>
        <member name="M:UniRx.UnityUIComponentExtensions.OnClickAsObservable(UnityEngine.UI.Button)">
            <summary>Observe onClick event.</summary>
        </member>
        <member name="M:UniRx.UnityUIComponentExtensions.OnValueChangedAsObservable(UnityEngine.UI.Toggle)">
            <summary>Observe onValueChanged with current `isOn` value on subscribe.</summary>
        </member>
        <member name="M:UniRx.UnityUIComponentExtensions.OnValueChangedAsObservable(UnityEngine.UI.Scrollbar)">
            <summary>Observe onValueChanged with current `value` on subscribe.</summary>
        </member>
        <member name="M:UniRx.UnityUIComponentExtensions.OnValueChangedAsObservable(UnityEngine.UI.ScrollRect)">
            <summary>Observe onValueChanged with current `normalizedPosition` value on subscribe.</summary>
        </member>
        <member name="M:UniRx.UnityUIComponentExtensions.OnValueChangedAsObservable(UnityEngine.UI.Slider)">
            <summary>Observe onValueChanged with current `value` on subscribe.</summary>
        </member>
        <member name="M:UniRx.UnityUIComponentExtensions.OnEndEditAsObservable(UnityEngine.UI.InputField)">
            <summary>Observe onEndEdit(Submit) event.</summary>
        </member>
        <member name="M:UniRx.UnityUIComponentExtensions.OnValueChangeAsObservable(UnityEngine.UI.InputField)">
            <summary>Observe onValueChange with current `text` value on subscribe.</summary>
        </member>
        <member name="M:UniRx.UnityUIComponentExtensions.OnValueChangedAsObservable(UnityEngine.UI.InputField)">
            <summary>Observe onValueChanged with current `text` value on subscribe.</summary>
        </member>
    </members>
</doc>
